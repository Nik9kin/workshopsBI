/*global Raphael*/
/*global $*/
Raphael.fn.pieChart = function(cx, cy, r, values, options) {
  "use strict";
  var defaults = {
    stroke: 1,
    colors: [ "#060", "#999", "#FFC200" ]
  };
  var settings = $.extend({}, defaults, options);
  var paper = this;
  var rad = Math.PI / 180;
  var chart = this.set();
  var angle = 0;
  var total = 0;
  var process = function(value, j) {
    var angleplus = 360 * value / total;
    var p = sector(cx, cy, r, angle, angle + angleplus, {
      fill: settings.colors[j],
      stroke: settings.stroke,
      "stroke-width": 1,
      "fill-opacity": .8,
      "stroke-opacity": .8
    });
    angle += angleplus;
    chart.push(p);
  };
  var sector = function(cx, cy, r, startAngle, endAngle, params) {
    var x1 = cx + r * Math.cos(-startAngle * rad);
    var x2 = cx + r * Math.cos(-endAngle * rad);
    var y1 = cy + r * Math.sin(-startAngle * rad);
    var y2 = cy + r * Math.sin(-endAngle * rad);
    if (x1 === x2 && y1 === y2) {
      return paper.circle(cx, cy, r).attr(params);
    } else {
      return paper.path([ "M", cx, cy, "L", x1, y1, "A", r, r, 0, +(endAngle - startAngle > 180), 0, x2, y2, "z" ]).attr(params);
    }
  };
  total = values.reduce(function(prev, curr) {
    return prev + curr;
  }, total);
  values.forEach(process);
  // add a transparent circle over the existing chart that
  // will act as anchor for events
    chart.push(paper.circle(cx, cy, r).attr({
    fill: settings.colors[1],
    stroke: settings.stroke,
    "stroke-width": 0,
    "fill-opacity": 0,
    "stroke-opacity": 0
  }).toFront());
  return chart;
};

if (!window.__HmmerGlobal) window.__HmmerGlobal = {};

if (!window.isFinite) {
  window.isFinite = function(n) {
    return typeof n === "number" && n !== Infinity && n !== -Infinity && n === n;
  };
}

__HmmerGlobal.PfamGraphic = function($) {
  return function(parent, sequence) {
    "use strict";
    this._middleClickListenerAdded = false;
    this._imageParams = {
      headSizeCircle: 3,
      headSizeSquare: 6,
      headSizeDiamond: 4,
      headSizeArrow: 3,
      headSizePointer: 3,
      headSizeLine: 3,
      sequenceEndPadding: 2,
      xOffset: 0,
      yOffset: 0,
      defaultMarkupHeight: 20,
      lollipopToLollipopIncrement: 7,
      bridgeToBridgeIncrement: 2,
      bridgeToLollipopIncrement: 5,
      largeJaggedSteps: 6,
      fontSize: "10px",
      regionHeight: 20,
      motifHeight: 14,
      motifOpacity: .6,
      labelPadding: 3,
      residueWidth: .5,
      xscale: 1,
      yscale: 1,
      envOpacity: .6,
      highlightWeight: 1,
      highlightColour: "#000"
    };
    this._options = {
      baseUrl: "",
      imageMap: true,
      labels: true,
      tips: true,
      tipStyle: "pfam",
      newCanvas: true
    };
    this._markupSpec = {
      valignValues: [ "top", "bottom" ],
      linesStyleValues: [ "mixed", "bold", "dashed" ],
      lollipopHeadValues: [ "diamond", "circle", "square", "arrow", "pointer", "line" ],
      regionEndValues: [ "curved", "straight", "jagged", "arrow" ]
    };
    this._heights = {};
    this._areasHash = {};
    this._cache = {};
    this._saveLevel = 0;
    this._rendered_regions = {};
    this._highlighted = {};
    // support functions
        this._parseInt = function(value) {
      var num = parseInt(value, 10);
      return num !== "NaN" ? num : value;
    };
    this.capitalize = function(word) {
      return word.charAt(0).toUpperCase() + word.substring(1).toLowerCase();
    };
    this._getRGBColour = function(hexString) {
      var longHexMatches = /^#?([A-F0-9]{6})$/i.exec(hexString);
      var shortHexMatches = /^#?([A-F0-9]{3})$/i.exec(hexString);
      var h;
      var r;
      var g;
      var b;
      if (!longHexMatches && !shortHexMatches) {
        this._throw("not a valid hex color ('" + hexString + "')");
      }
      if (longHexMatches) {
        h = longHexMatches[1];
        r = parseInt(h.substr(0, 2), 16);
        g = parseInt(h.substr(2, 2), 16);
        b = parseInt(h.substr(4, 2), 16);
      } else if (shortHexMatches) {
        h = shortHexMatches[1];
        r = parseInt(h.substr(0, 1) + h.substr(0, 1), 16);
        g = parseInt(h.substr(1, 1) + h.substr(1, 1), 16);
        b = parseInt(h.substr(2, 1) + h.substr(2, 1), 16);
      }
      var rgb = [ r, g, b ];
      rgb.r = r;
      rgb.g = g;
      rgb.b = b;
      return rgb;
    };
    // end support functions
        this.setParent = function(parent) {
      this._parent = $(parent);
      if (!this._parent.length) this._throw("couldn't find the parent node");
      return this;
    };
    if (parent) {
      this.setParent(parent);
    }
    this._walkSequence = function() {
      var self = this;
      var s = this._sequence;
      s.length = this._parseInt(s.length);
      [ s.motifs, s.regions, s.markups ].forEach(function(arr) {
        arr.forEach(function(item) {
          item.start = self._parseInt(item.start);
          item.end = self._parseInt(item.end);
          item.aliStart = self._parseInt(item.aliStart);
          item.aliEnd = self._parseInt(item.aliEnd);
        });
      });
    };
    this._buildMarkups = function() {
      var self = this;
      var heights = {
        lollipops: {
          up: [],
          down: [],
          markups: [],
          downMax: 0,
          upMax: 0
        },
        bridges: {
          up: [],
          down: [],
          markups: [],
          downMax: 0,
          upMax: 0
        }
      };
      var bridgeMarkups = [];
      var ip = this._imageParams;
      var ms = this._markupSpec;
      var orderedMarkups = this._sequence.markups.map(function(markup) {
        markup.start = Math.floor(markup.start);
        return markup;
      }).filter(function(markup) {
        return isFinite(markup.start);
      });
      var residueWidth = this._imageParams.residueWidth;
      orderedMarkups.forEach(function(markup) {
        if (!isFinite(markup.end)) {
          heights.lollipops.markups.push(markup);
        } else {
          bridgeMarkups.push(markup);
          return;
        }
        if (markup.v_align !== undefined && ms.valignValues.indexOf(markup.v_align) === -1) {
          this._throw("markup 'v_align' value is not valid: '" + markup.v_align + "'");
        }
        if (markup.headStyle !== undefined && ms.lollipopHeadValues.indexOf(markup.headStyle) === -1) {
          this._throw("markup 'headStyle' value is not valid: '" + markup.headStyle + "'");
        }
        var up = !markup.v_align || markup.v_align === "top";
        var h = heights.lollipops[up ? "up" : "down"];
        // Calculating firstLollipopHeight would sometime result in NaN
        // for now we just removed the functionality and set all lollipops
        // to the same height
        // if (
        //   h[markup.start - (1 / residueWidth)] ||
        //   h[markup.start] ||
        //   h[markup.start + (1 / residueWidth)]
        // ) {
        //   var firstLollipopHeight = Math.max.apply(
        //     Math, h.slice(markup.start - (1 / residueWidth),
        //       markup.start + (1 / residueWidth))
        //   );
        //   h[markup.start] = firstLollipopHeight + ip.lollipopToLollipopIncrement;
        // } else {
        //   h[markup.start] = ip.defaultMarkupHeight;
        // }
                h[markup.start] = ip.defaultMarkupHeight;
        var headSize = ip["headSize" + self.capitalize(markup.headStyle)];
        if (up) {
          heights.lollipops.upMax = Math.max(h[markup.start] + headSize, heights.lollipops.upMax);
        } else {
          heights.lollipops.downMax = Math.max(h[markup.start] + headSize, heights.lollipops.downMax);
        }
      });
      bridgeMarkups.forEach(function(bridgeMarkup) {
        var bridge = {
          markup: bridgeMarkup
        };
        heights.bridges.markups.push(bridge);
        var start = Math.floor(bridgeMarkup.start);
        if (start === "NaN") {
          this._throw("bridge start position is not a number: '" + bridgeMarkup.start + "'");
        }
        var end = Math.floor(bridgeMarkup.end);
        if (end === "NaN") {
          this._throw("bridge end position is not a number: '" + bridgeMarkup.end + "'");
        }
        bridge.up = !bridgeMarkup.v_align || bridgeMarkup.v_align === "top";
        var hl = heights.lollipops[bridge.up ? "up" : "down"];
        var hb = heights.bridges[bridge.up ? "up" : "down"];
        var maxBridgeHeight = Math.max.apply(Math, hb.slice(start, end).map(function(item) {
          return item;
        }));
        var bridgeHeight = ip.defaultMarkupHeight;
        if (maxBridgeHeight !== -Infinity && hb.slice(start, end).indexOf(bridgeHeight) !== -1) {
          bridgeHeight = maxBridgeHeight + ip.bridgeToBridgeIncrement;
        }
        var maxLollipopHeight = Math.max.apply(Math, hl.slice(start - 4, end + 4));
        if (maxLollipopHeight !== undefined && maxLollipopHeight + ip.bridgeToLollipopIncrement >= bridgeHeight) {
          bridgeHeight = maxLollipopHeight + ip.bridgeToLollipopIncrement;
        }
        bridge.height = bridgeHeight;
        for (var i = start; i <= end; i++) {
          if (hb[i] === undefined) {
            hb[i] = [];
          }
          hb[i].push(bridgeHeight);
        }
        if (bridge.up) {
          heights.bridges.upMax = Math.max(bridgeHeight, heights.bridges.upMax) + 2;
        } else {
          heights.bridges.downMax = Math.max(bridgeHeight, heights.bridges.downMax) + 2;
        }
      });
      this._heights = heights;
    };
    this.setImageParams = function(params) {
      if (params !== undefined) {
        if (typeof params !== "object") {
          this._throw("'imageParams' must be a valid object");
        }
        for (var key in params) {
          if (params.hasOwnProperty(key)) {
            this._imageParams[key] = params[key];
          }
        }
      }
    };
    this.setSequence = function(sequence) {
      if (typeof sequence !== "object") {
        this._throw("must supply a valid sequence object");
      }
      if (sequence.length === undefined) {
        this._throw("must specify a sequence length");
      }
      if (isNaN(sequence.length)) {
        this._throw("sequence length must be a valid number");
      }
      if (parseInt(sequence.length, 10) <= 0) {
        this._throw("sequence length must be a positive integer");
      }
      if (sequence.regions !== undefined) {
        if (typeof sequence.regions !== "object") {
          this._throw("'regions' must be a valid object");
        }
      } else {
        sequence.regions = [];
      }
      if (sequence.markups !== undefined) {
        if (typeof sequence.markups !== "object") {
          this._throw("'markups' must be a valid object");
        }
      } else {
        sequence.markups = [];
      }
      if (sequence.motifs !== undefined) {
        if (typeof sequence.motifs !== "object") {
          this._throw("'motifs' must be a valid object");
        }
      } else {
        sequence.motifs = [];
      }
      if (sequence.options !== undefined) {
        if (typeof sequence.options !== "object") {
          this._throw("'options' must be a valid object");
        }
        for (var key in sequence.options) {
          if (sequence.options.hasOwnProperty(key)) {
            this._options[key] = sequence.options[key];
          }
        }
      }
      if (sequence.imageParams !== undefined) {
        if (typeof sequence.imageParams !== "object") {
          this._throw("'imageParams' must be a valid object");
        }
        this.setImageParams(sequence.imageParams);
      }
      this._sequence = sequence;
      this._walkSequence();
      this._imageWidth = this._sequence.length * this._imageParams.residueWidth + this._imageParams.sequenceEndPadding;
      if (this._parent.width() < this._imageWidth) {
        this._imageWidth = this._parent.width();
      }
      this._regionHeight = this._imageParams.regionHeight;
      this._seqHeight = Math.round(this._regionHeight / 6);
      this._seqStep = Math.round(this._seqHeight / 5);
      this._buildMarkups();
      this._canvasHeight = Math.max.apply(Math, [ this._heights.lollipops.upMax, this._heights.bridges.upMax, this._regionHeight / 2 + 1 ]) + Math.max.apply(Math, [ this._heights.lollipops.downMax, this._heights.bridges.downMax, this._regionHeight / 2 + 1 ]) + 5;
      this._canvasHeight *= this._imageParams.yscale;
      if (this._sequence.highlight !== undefined) {
        this._canvasHeight += 5 + Math.ceil(this._imageParams.highlightWeight / 2);
      }
      this._canvasWidth = this._imageWidth + 1 + this._imageParams.sequenceEndPadding * 2;
      this._canvasWidth *= this._imageParams.xscale;
      this._baseline = Math.max.apply(Math, [ this._heights.lollipops.upMax, this._heights.bridges.upMax, this._imageParams.regionHeight / 2 ]) + 1;
      return this;
    };
    if (sequence) {
      this.setSequence(sequence);
    }
    this._throw = function(message) {
      throw {
        name: "PfamGraphicException",
        message: message,
        toString: function() {
          return this.message;
        }
      };
    };
    this.highlight = function(params) {
      // return unless we have a region name
      if (!params.uniq) return;
      if (!this._rendered_regions[params.uniq]) return;
      if (!params.status || params.status === "on") {
        // highlight the named region
        if (!this._highlighted[params.uniq]) {
          this._highlighted[params.uniq] = [];
        }
        this._rendered_regions[params.uniq].forEach(function(rr, i) {
          this[i] = rr.glow({
            width: 5,
            opacity: .6
          });
        }, this._highlighted[params.uniq]);
      } else {
        // turn off the highlight
        this._highlighted[params.uniq].forEach(function(hl) {
          hl.remove();
        });
        delete this._highlighted[params.uniq];
      }
    };
    this.render = function(parent, sequence) {
      if (sequence) this.setSequence(sequence);
      if (parent) this.setParent(parent);
      if (!this._sequence) this._throw("sequence was not supplied");
      if (this._options.newCanvas && !this._parent) {
        this._throw("parent node was not supplied");
      }
      if (!this._canvas || this._options.newCanvas) {
        this._buildCanvas(this._canvasWidth, this._canvasHeight);
      }
      var all_elements = this._draw();
      this._drawTitle(all_elements);
      // draw the sliding marker
            var marker = this._canvas.rect(-100, 0, 1, this._canvas.height).attr({
        fill: "#666",
        "stroke-opacity": 0
      });
      var self = this;
      function scale(coord, orig, desired) {
        var scaled = desired * coord / orig;
        return scaled;
      }
      this._parent.find("svg").on("coverage.move", function(e, position) {
        var seq_length_in_px = self._canvas.width - 100 - (self._labelWidth + 7);
        var x = Math.round(scale(position, self._sequence.length, seq_length_in_px) + 100);
        marker.attr({
          x: x
        });
      });
      // end the sliding marker
            if (!this._listeningToResize) {
        this._listeningToResize = true;
        window.addEventListener("resize", function() {
          self._parent.children().remove();
          self.render();
        });
      }
      return this;
    };
    this._drawTitle = function(graphics) {
      if (!this._sequence.title) return;
      //shift all the graphics to the right
            graphics.transform("t100,0");
      this._canvas.setSize(this._canvas.width + 100, this._canvas.height);
      this._canvas.text(50, this._canvas.height / 2 - 2, this._sequence.title);
    };
    this.resize = function(width, height) {
      if (width > this._canvasWidth) return;
      if (!width) {
        width = this._canvasWidth;
      }
      if (!height) {
        height = this._canvasHeight;
      }
      var seq_length = this._sequence.length * this._imageParams.residueWidth;
      if (this._sequence.title) {
        seq_length = seq_length + 100;
      }
      if (this._labelWidth) {
        seq_length = seq_length + this._labelWidth + 5;
      }
      this._canvas.setSize(width, height);
      this._canvas.setViewBox(0, 0, seq_length, height);
      return this;
    };
    this._buildCanvas = function(width, height) {
      var wrapperDiv = this._parent.closest("div");
      if (wrapperDiv && width > wrapperDiv.scrollWidth) {
        this._parent.addClassName("canvasScroller");
      }
      var canvas = Raphael(this._parent.get(0), width, height);
      this._canvas = canvas;
      if (!this._canvas) {
        this._throw("couldn't find the canvas node");
      }
      this._areasList = [];
      return this;
    };
    this._drawRegion = function(region) {
      if (this._markupSpec.regionEndValues.indexOf(region.startStyle) === -1) {
        this._throw("region start style is not valid: '" + region.startStyle + "'");
      }
      if (this._markupSpec.regionEndValues.indexOf(region.endStyle) === -1) {
        this._throw("region end style is not valid: '" + region.endStyle + "'");
      }
      var height = Math.floor(this._regionHeight) - 2;
      var radius = Math.round(height / 2);
      var arrow = radius;
      var width = (region.end - (region.start + 1)) * this._imageParams.residueWidth + 1;
      var x = Math.max(1, Math.floor(region.start * this._imageParams.residueWidth));
      var y = Math.floor(this._baseline - radius) + .5;
      if (arrow * 2 > width) {
        arrow = width / 2;
        radius = arrow;
      }
      var regionParams = {
        x: x,
        y: y,
        w: width,
        h: height,
        r: radius,
        a: arrow,
        s: region.startStyle,
        e: region.endStyle
      };
      var path = this._buildRegionPath(regionParams, region);
      var fill = "90-#fff-" + region.color + ":50-" + region.color + ":70-#fff";
      var glyph = this._canvas.path(path).attr({
        stroke: region.color,
        fill: fill
      });
      if (region.metadata) {
        if (!this._rendered_regions[region.metadata._uniq]) {
          this._rendered_regions[region.metadata._uniq] = [];
        }
        this._rendered_regions[region.metadata._uniq].push(glyph);
      }
      if (region.aliStart !== undefined && region.aliEnd !== undefined) {
        this._drawEnvelope(region, radius, height);
      }
      if (this._options.labels) {
        this._drawText(x, this._baseline, width, region.text);
      }
      var area = this._canvas.rect(x, y, width, height).attr({
        opacity: 0,
        fill: "#000"
      });
      this._buildTip(region, area);
    };
    this._buildTip = function(item, glyph, type) {
      if (!window.jQuery || !window.jQuery.fn.qtip) return;
      if (item.metadata === undefined) {
        return;
      }
      var md = item.metadata;
      var tipTitle;
      if (md.accession !== undefined && md.identifier !== undefined) {
        tipTitle = md.identifier + " (" + md.accession.toUpperCase() + ")";
      } else if (md.identifier !== undefined) {
        tipTitle = md.identifier;
      } else if (md.accession !== undefined) {
        tipTitle = md.accession.toUpperCase();
      } else {
        tipTitle = md.type;
      }
      var coords = '<span class="inactive">n/a</span>';
      if (md.start !== undefined && md.end !== undefined) {
        coords = md.start + " - " + md.end;
        if (md.aliStart !== undefined && md.aliEnd !== undefined) {
          coords = coords.concat(" (alignment region " + md.aliStart + " - " + md.aliEnd + ")");
        }
      }
      var desc = md.description || '<span class="inactive">n/a</span>';
      if (md.accession) {
        desc += ' [<a href="' + item.href + '" class="ext">' + md.database + "</a>]";
      }
      if (type && type === "motif") {
        if (md.href) {
          desc = md.description + ' [<a href="' + md.href + '" class="ext">' + md.src + "</a>]";
        }
      }
      var model;
      if (item.modelStart) {
        // work out the width of the match
        var match_width = item.modelEnd - item.modelStart + 1;
        var scaled_match_width = match_width * 200 / item.modelLength;
        // work out the start
                var scaled_start = (item.modelStart - 1) / (item.modelLength / 200);
        var match = '<span class="model_position"><span style="width: ' + scaled_match_width + "px;background: " + item.color + ";left: " + scaled_start + 'px"></span></span>';
        model = "1" + match + item.modelLength;
      }
      var tipBody = "<tr><td>Description:</td><td>" + desc + "</td></tr>";
      tipBody += "<tr><td>Coordinates:</td><td>" + coords + "</td></tr>";
      if (model) {
        tipBody += "<tr><td>Model Match:</td><td>" + model + "</td></tr>";
      }
      tipBody = "<table>" + tipBody + "</table>";
      $(glyph.node).qtip({
        position: {
          viewport: $(window),
          my: "bottom center",
          at: "top center"
        },
        content: {
          title: tipTitle,
          text: tipBody
        },
        show: {
          solo: true,
          event: "mouseover"
        },
        hide: {
          fixed: true,
          delay: 250,
          event: "mouseout"
        },
        style: {
          classes: "ui-tooltip-hmmer ui-tooltip-rounded"
        }
      });
    };
    this._drawText = function(x, midpoint, regionWidth, text) {
      var textX = x + regionWidth / 2;
      var ts = this._canvas.text(textX, midpoint, text).attr({
        stroke: "#eee",
        "stroke-width": 2,
        "stroke-opacity": .7
      });
      var bbox = ts.getBBox();
      if (bbox.width > regionWidth || bbox.height > this._regionHeight) {
        ts.remove();
      } else {
        this._canvas.text(textX, midpoint, text);
      }
    };
    this._drawEnvelope = function(region, radius, height) {
      if (parseInt(region.start, 10) > parseInt(region.aliStart, 10)) {
        this._throw("regions must have start <= aliStart (" + region.start + " is > " + region.aliStart + ")");
      }
      if (parseInt(region.end, 10) < parseInt(region.aliEnd, 10)) {
        this._throw("regions must have end >= aliEnd (" + region.end + " is < " + region.aliEnd + ")");
      }
      var y = this._baseline - radius;
      var xs = this._imageParams.residueWidth;
      var l;
      var r;
      var fillStyle = {
        opacity: this._imageParams.envOpacity,
        fill: "#fff",
        stroke: "#fff"
      };
      if (region.aliStart && region.aliStart > region.start) {
        l = {
          x: Math.floor(region.start * xs),
          y: Math.floor(y - 1) + 1,
          w: Math.floor(region.aliStart * xs) - Math.floor(region.start * xs) + 1,
          h: height + 1
        };
        this._canvas.rect(l.x, l.y, l.w, l.h).attr(fillStyle);
      }
      if (region.aliEnd && region.aliEnd < region.end) {
        r = {
          x: Math.floor(region.aliEnd * xs) + 1,
          y: Math.floor(y - 1) + 1,
          w: Math.floor(region.end * xs) - Math.floor(region.aliEnd * xs),
          h: height + 1
        };
        this._canvas.rect(r.x, r.y, r.w, r.h).attr(fillStyle);
      }
    };
    this._buildRegionPath = function(params) {
      var path = "M";
      // move to top left of region
      // draw left side down to bottom of region
            switch (params.s) {
       case "curved":
        path += params.x + params.r + " " + params.y + this._drawLeftRounded(params.r, params.h);
        break;

       case "jagged":
        path += params.x + " " + params.y + this._drawJagged(params.x, params.y, params.h, true);
        break;

       case "straight":
        path += params.x + " " + params.y + "l0 " + params.h;
        break;

       case "arrow":
        path += params.x + params.a + " " + params.y + this._drawLeftArrow(params.a, params.h);
        break;
      }
      // draw horizontal line from bottom left to bottom right
            if (params.s.match(/^curved|arrow$/) && params.e.match(/^curved|arrow$/)) {
        var l_width = Math.max(params.w - params.r * 2, 0);
        path += "l" + l_width + " 0";
      } else if (params.s.match(/^curved|arrow$/) || params.e.match(/^curved|arrow$/)) {
        path += "l" + (params.w - params.r) + " 0";
      } else {
        path += "l" + params.w + " 0";
      }
      // draw right side up to top of region
            switch (params.e) {
       case "curved":
        path += this._drawRightRounded(params.r, params.h);
        break;

       case "jagged":
        path += this._drawJagged(params.x + params.w, params.y + params.h, params.h, false);
        break;

       case "straight":
        path += "l0 -" + params.h;
        break;

       case "arrow":
        path += this._drawRightArrow(params.a, params.h);
        break;
      }
      // close path - complete line from right to left top
            path += "z";
      return path;
    };
    var drawRounded = function(radius, height) {
      return "c" + radius + " " + 0 + " " + radius + " " + -height + " " + 0 + " " + -height;
    };
    this._drawRightRounded = function(radius, height) {
      return drawRounded(radius + 2, height);
    };
    this._drawLeftRounded = function(radius, height) {
      return drawRounded(-radius - 2, -height);
    };
    var drawArrow = function(arrow, height) {
      return "l" + -arrow + " " + height / 2 + "l" + arrow + " " + height / 2;
    };
    this._drawLeftArrow = function(arrow, height) {
      return drawArrow(arrow, height);
    };
    this._drawRightArrow = function(arrow, height) {
      return drawArrow(-arrow, -height);
    };
    this._drawJagged = function(x, y, height, left) {
      var steps = parseInt(this._imageParams.largeJaggedSteps, 10);
      steps += steps % 2;
      var yShifts = this._getSteps(height, steps);
      var step = height / steps;
      var modif = left ? 1 : -1;
      var path = yShifts.reduce(function(path, yShift, i) {
        return path + "L" + (x + (i % 2 !== 0 ? 0 : step * modif)) + " " + (y + yShift * modif);
      }, "");
      return path + "L" + x + " " + (y + height * (left ? 1 : -1));
    };
    this._getSteps = function(height, steps) {
      var cacheKey = "shifts_" + height + "_" + steps;
      var list = this._cache[cacheKey];
      if (list === undefined) {
        var step = height / steps;
        var yShifts = [];
        for (var i = 0; i < steps / 2; i++) {
          yShifts.push(height / 2 - i * step);
          yShifts.push(height / 2 + i * step);
        }
        list = yShifts.sort(function(a, b) {
          return a - b;
        }).reduce(function(acc, cur) {
          // If the last element of the accumulated array is different
          if (acc[acc.length - 1] !== cur) {
            // Adds it to the list
            acc.push(cur);
          }
          // The accumulated array only contains unique values
          return acc;
        }, []);
        this._cache[cacheKey] = list;
      }
      return list;
    };
    this._drawBridge = function(bridge) {
      var self = this;
      var start = bridge.markup.start;
      var end = bridge.markup.end;
      var height = bridge.height;
      var up = bridge.up;
      var color = "#000";
      var x1 = Math.floor(start * this._imageParams.residueWidth) + 1.5;
      var x2 = Math.floor(end * this._imageParams.residueWidth) + 1.5;
      var y1 = Math.round(up ? this._topOffset : this._botOffset) + .5;
      var y2 = up ? Math.ceil(this._baseline - height) - .5 : Math.floor(this._baseline + height) + .5;
      var xo = this._imageParams.xOffset;
 // need X- and Y-offsets
            var yo = this._imageParams.yOffset;
      if (bridge.markup.color.match("^\\#[0-9A-Fa-f]{6}$")) {
        color = bridge.markup.color;
      }
      var path = "M" + x1 + " " + y1 + "L" + x1 + " " + y2 + "L" + x2 + " " + y2 + "L" + x2 + " " + y1;
      this._canvas.path(path).attr({
        stroke: color || "#000"
      });
      var tip = {};
      if (bridge.markup.metadata) {
        var md = bridge.markup.metadata;
        tip.title = self.capitalize(md.type || "Bridge");
        tip.body = "<table><tr>" + "<td>Coordinates:</td>" + "<td>" + md.start + "-" + md.end + "</td>" + "</tr><tr>" + "<td>Source:</td>" + "<td>" + (md.database || '<span class="na">n/a</span>') + "</td>" + "</tr></table>";
      }
      var ys = y1 <= y2 ? [ y1, y2 ] : [ y2, y1 ];
      this._areasList.push({
        start: start,
        type: "bridge-start",
        color: color,
        end: end,
        tip: tip,
        coords: [ xo + x1 - 1, yo + ys[0] - 1, xo + x1 + 1, yo + ys[1] + 1 ]
      });
      this._areasList.push({
        start: start,
        type: "bridge-horizontal",
        color: color,
        end: end,
        tip: tip,
        coords: [ xo + x1 - 1, yo + ys[1] - 1, xo + x2 + 1, yo + ys[1] + 1 ]
      });
      this._areasList.push({
        start: start,
        type: "bridge-end",
        color: color,
        end: end,
        tip: tip,
        coords: [ xo + x2 - 1, yo + ys[0] - 1, xo + x2 + 1, yo + ys[1] + 1 ]
      });
    };
    this._drawLollipopHead = function(x, y1, y2, start, up, style, color, lineColour, tip) {
      var xo = this._imageParams.xOffset;
      var yo = this._imageParams.yOffset;
      var r;
      var d;
      var glyph;
      switch (style) {
       case "circle":
        r = this._imageParams.headSizeCircle;
        var strokeColor = color || "#f00";
        glyph = this._canvas.circle(x, y2, r).attr({
          fill: strokeColor,
          stroke: strokeColor
        });
        this._areasList.push({
          tip: tip,
          type: "lollipop-head",
          shape: "circle",
          color: color || "red",
          start: start,
          coords: [ xo + x - r, yo + y2 - r, xo + x + r, yo + y2 + r ]
        });
        break;

       case "square":
        d = this._imageParams.headSizeSquare / 2;
        var strokeColor = color || "#64c809";
        glyph = this._canvas.rect(x - d, y2 - d, d * 2, d * 2).attr({
          fill: strokeColor,
          stroke: strokeColor
        });
        this._areasList.push({
          tip: tip,
          type: "lollipop-head",
          start: start,
          color: color || "#64c809",
          coords: [ xo + x - d, yo + y2 - d, xo + x + d, yo + y2 + d ]
        });
        break;

       case "diamond":
        d = this._imageParams.headSizeDiamond;
        glyph = this._canvas.path("M" + x + "," + (y2 - d) + "L" + (x + d) + "," + y2 + "L" + x + "," + (y2 + d) + "L" + (x - d) + "," + y2 + "Z").attr({
          fill: color || "#64c809",
          "stroke-width": 0
        });
        this._areasList.push({
          tip: tip,
          type: "lollipop-head",
          shape: "poly",
          start: start,
          color: color || "#64c809",
          coords: [ xo + x - d, yo + y2 - d, xo + x + d, yo + y2 + d ]
        });
        break;

       case "line":
        d = this._imageParams.headSizeLine;
        this._canvas.path("M" + x + " " + (y2 - d) + "L" + x + " " + (y2 + d)).attr({
          stroke: color || "#3228ff"
        });
        glyph = this._areasList.push({
          tip: tip,
          type: "lollipop-head",
          start: start,
          color: color || "#3228ff",
          coords: [ xo + x - 1, yo + y2 - d - 1, xo + x + 1, yo + y2 + d + 1 ]
        });
        break;

       case "arrow":
        d = this._imageParams.headSizeArrow;
        this._canvas.path("M" + x + " " + y2 + "L" + x + " " + (y2 - d)).attr({
          stroke: lineColour || "#000"
        });
        this._canvas.path("M" + (x - d) + " " + (y2 + d * .5 - (up ? 0 : this._botOffset)) + "L" + x + " " + (y2 - d - (up ? 0 : this._botOffset)) + "L" + (x + d) + " " + (y2 + d * .5 - (up ? 0 : this._botOffset))).attr({
          stroke: color || "#3228ff"
        });
        this._areasList.push({
          tip: tip,
          type: "lollipop-head",
          color: color || "#3228ff",
          start: start,
          shape: "poly",
          coords: [ xo + x - d, yo + y2 - up ? 0 : d * 1.5, xo + x + d, yo + y2 + up ? d * .5 : -d ]
        });
        break;

       case "pointer":
        d = this._imageParams.headSizePointer;
        var path = "M" + (x - d) + " " + (y1 + d * 1.5 - (up ? 0 : this._botOffset)) + "L" + x + " " + (y1 - (up ? 0 : this._botOffset)) + "L" + (x + d) + " " + (y1 + d * 1.5 - (up ? 0 : this._botOffset));
        glyph = this._canvas.path(path).attr({
          stroke: color || "#3228ff"
        });
        this._areasList.push({
          tip: tip,
          type: "lollipop-head",
          color: color || "#3228ff",
          start: start,
          shape: "poly",
          coords: [ xo + x - d, yo + y1 + up ? 0 : d, xo + x + d, yo + y1 - up ? d : 0 ]
        });
        break;
      }
      if (glyph && tip) {
        $(glyph.node).qtip({
          position: {
            my: "bottom center",
            at: "top center",
            viewport: $(window),
            target: "mouse"
          },
          content: {
            title: tip.title,
            text: tip.body
          },
          show: {
            solo: true,
            event: "mouseover"
          },
          hide: {
            fixed: true,
            delay: 250,
            event: "mouseout"
          },
          style: {
            classes: "ui-tooltip-hmmer ui-tooltip-rounded"
          }
        });
      }
    };
    this._drawHit = function(hit) {
      var xs = this._imageParams.residueWidth;
      var len = Math.floor(hit.tend * xs) - Math.floor(hit.tstart * xs);
      var fillStyle = {
        fill: "#666",
        stroke: "#000",
        opacity: 1
      };
      var x = Math.floor(hit.tstart * xs);
      var y = this._canvasHeight - 4;
      var glyph = this._canvas.rect(x, y, len, 2).attr(fillStyle);
      $(glyph.node).qtip({
        position: {
          viewport: $(window),
          my: "left top",
          at: "right center"
        },
        content: {
          title: "Match Coordinates",
          text: "<table><tr>" + "<td>Target:</td><td>" + hit.tstart + " - " + hit.tend + "</td>" + "</tr><tr>" + "<td>Query:</td><td>" + hit.qstart + " - " + hit.qend + "</td>" + "</tr></table>"
        },
        show: {
          solo: true
        },
        style: {
          classes: "ui-tooltip-hmmerdist ui-tooltip-rounded"
        }
      });
    };
    this._drawLollipop = function(markup) {
      var self = this;
      var start = markup.start;
      var up = markup.v_align === undefined || markup.v_align === "top";
      var x1 = Math.floor(start * this._imageParams.residueWidth) + 1.5;
      var y1;
      var y2;
      if (up) {
        y1 = Math.round(this._topOffset + 1) - .5;
        y2 = Math.floor(y1 - this._heights.lollipops.up[start] + (this._baseline - this._topOffset) + 1);
      } else {
        y1 = Math.round(this._botOffset + 1) - .5;
        y2 = Math.ceil(y1 + this._heights.lollipops.down[start] - (this._botOffset - this._baseline) - 1);
      }
      var path = "M" + x1 + " " + y1 + "L" + x1 + " " + y2;
      var strokeColor = markup.lineColour || "#000";
      this._canvas.path(path).attr({
        stroke: strokeColor
      });
      var xo = this._imageParams.xOffset;
      var yo = this._imageParams.yOffset;
      var ys = [ y1, y2 ].sort(function(a, b) {
        return a - b;
      });
      var area = {
        start: start,
        type: "lollipop",
        coords: [ xo + Math.floor(x1) - 1, yo + ys[0] - 1, xo + Math.floor(x1) + 1, yo + ys[1] + 1 ]
      };
      this._areasList.push(area);
      if (markup.href !== undefined) {
        area.href = markup.href;
      }
      var tip = {};
      if (markup.metadata) {
        var md = markup.metadata;
        tip.title = self.capitalize(md.type || "Annotation");
        tip.body = "<table><tr>" + "<td>Description:</td>" + "<td>" + md.description + "</td>" + "</tr><tr>" + "<td>Evidence:</td>" + "<td>" + md.evidence + "</td>" + "</tr><tr>" + "<td>Position:</td>" + "<td>" + md.start + "</td>" + "</tr><tr>" + "<td>Source:</td>" + "<td>" + (md.database || '<span class="na">n/a</span>') + "</td>" + "</tr></table>";
      }
      area.tip = tip;
      if (markup.headStyle) {
        this._drawLollipopHead(x1, y1, y2, start, up, markup.headStyle, markup.color, markup.lineColour, area.tip);
      }
    };
    this._draw = function() {
      var self = this;
      this._canvas.setStart();
      if (this._applyImageParams) {
        this._applyImageParams = false;
      }
      this._drawSequence();
      this._heights.bridges.markups.forEach(function(bridge) {
        if (bridge.display !== undefined && bridge.display !== null && !bridge.display) {
          return;
        }
        self._drawBridge(bridge);
      });
      this._heights.lollipops.markups.forEach(function(lollipop) {
        if (!lollipop.display) return;
        self._drawLollipop(lollipop);
      });
      this._sequence.regions.forEach(function(region) {
        if (region.display !== undefined && region.display !== null && !region.display) {
          return;
        }
        self._drawRegion(region);
      });
      if (this._sequence.hits) {
        this._sequence.hits.forEach(function(hit) {
          self._drawHit(hit);
        });
      }
      this._sequence.motifs.forEach(function(motif) {
        if (motif.display !== undefined && motif.display !== null && !motif.display) {
          return;
        }
        self._drawMotif(motif);
      });
      if (this._sequence.highlight !== undefined && parseInt(this._sequence.highlight.start, 10) && parseInt(this._sequence.highlight.end, 10)) {
        this._drawHighlight();
      }
      return this._canvas.setFinish();
    };
    this._drawMotif = function(motif) {
      var self = this;
      motif.start = parseInt(motif.start, 10);
      motif.end = parseInt(motif.end, 10);
      var height = Math.floor(this._imageParams.motifHeight) - 2;
      var radius = Math.round(height / 2);
      var width = (motif.end - motif.start + 1) * this._imageParams.residueWidth;
      var x = Math.max(1, Math.floor(motif.start * this._imageParams.residueWidth) + 1);
      var y = Math.floor(this._baseline - radius) + .5;
      var glyph = undefined;
      var color;
      if (motif.color instanceof Array) {
        if (motif.color.length !== 3) {
          this._throw("motifs must have either one or three colors");
        }
        var ip = this._imageParams;
        color = motif.color.map(function(c) {
          var rgbColour = self._getRGBColour(c);
          return {
            rgb: "rgb(" + rgbColour.join(",") + ")",
            rgba: "rgba(" + rgbColour.join(",") + "," + ip.motifOpacity + ")"
          };
        });
        var step = Math.round(height / 3);
        for (var i = 0; i < 3; i++) {
          glyph = this._canvas.rect(x, y + step * i, width, step).attr({
            fill: color[i].rgb,
            "stroke-opacity": 0
          });
        }
      } else {
        color = this._getRGBColour(motif.color);
        var rgb = "rgb(" + color.join(",") + ")";
        glyph = this._canvas.rect(x, y, width, parseInt(height, 10) + 1).attr({
          fill: rgb,
          opacity: this._imageParams.motifOpacity,
          "stroke-opacity": 0
        });
      }
      if (motif.metadata !== undefined && motif.metadata.identifier !== undefined) {
        motif.metadata.description = motif.metadata.identifier;
      } else if (motif.text !== undefined) {
        motif.metadata.description = motif.text;
      } else {
        motif.metadata.description = "motif, " + motif.start + " - " + motif.end;
      }
      var xo = this._imageParams.xOffset;
      var yo = this._imageParams.yOffset;
      var area = {
        text: motif.metadata.description,
        type: "motif",
        start: motif.aliStart || motif.start,
        end: motif.aliEnd || motif.end,
        color: color,
        coords: [ xo + x, yo + y, xo + x + width, yo + y + height ]
      };
      this._areasList.push(area);
      if (motif.href !== undefined) {
        area.href = motif.href;
      }
      this._buildTip(motif, glyph, "motif");
    };
    this._drawSequence = function() {
      this._topOffset = Math.floor(this._baseline - this._seqHeight / 2);
      this._botOffset = Math.floor(this._baseline + this._seqHeight / 2 + 1);
      var seq_length = this._sequence.length * this._imageParams.residueWidth;
      var gradient = this._canvas.rect(1, this._topOffset + .5, seq_length, this._seqHeight / 2 * 3);
      gradient.attr({
        fill: "270-#999-#eee:40-#ccc:60-#999",
        stroke: "none"
      });
      var lengthLabel = this._canvas.text(this._sequence.length * this._imageParams.residueWidth + 5, this._topOffset + this._seqHeight / 2, this._sequence.length);
      lengthLabel.attr({
        "text-anchor": "start"
      });
      // now that we have a label,
      // we are going to have to resize the canvas to fit it on.
            var labelWidth = lengthLabel.getBBox().width;
      this._labelWidth = labelWidth;
      this._canvas.setSize(this._canvasWidth + labelWidth, this._canvasHeight);
      var xo = this._imageParams.xOffset;
      var yo = this._imageParams.yOffset;
      return {
        label: "sequence",
        text: "sequence",
        coords: [ xo, yo + this._topOffset, xo + this._imageWidth, yo + this._topOffset + this._seqStep * 5 ]
      };
    };
  };
}(jQuery);

(function($) {
  "use strict";
  var scale = function(coord, orig, desired) {
    var scaled = desired * coord / orig;
    return scaled;
  };
  var getNiceFraction = function(frac, round) {
    if (round) {
      if (frac >= 7) return 10;
      if (frac >= 3) return 5;
      if (frac >= 1.5) return 2;
      return 1;
    }
    if (frac > 5) return 10;
    if (frac > 2) return 5;
    if (frac > 1) return 2;
    return 1;
  };
  var nice_number = function(value, round) {
    // :latex: \log_y z = \frac{\log_x z}{\log_x y}
    var exponent = Math.floor(Math.log(value) / Math.log(10));
    var fraction = value / Math.pow(10, exponent);
    return getNiceFraction(fraction, round) * Math.pow(10, exponent);
  };
  var nice_bounds = function(axis_start, axis_end, num_ticks) {
    //default value is 10
    num_ticks = num_ticks || 10;
    var axis_width = axis_end - axis_start;
    if (axis_width === 0) {
      axis_start -= .5;
      axis_end += .5;
      axis_width = axis_end - axis_start;
    }
    var nice_range = nice_number(axis_width);
    var nice_tick = nice_number(nice_range / (num_ticks - 1), true);
    var axis_start = Math.floor(axis_start / nice_tick) * nice_tick;
    var axis_end = Math.ceil(axis_end / nice_tick) * nice_tick;
    return {
      min: axis_start,
      max: axis_end,
      steps: nice_tick
    };
  };
  // Hit Profile Graphic
    function HitProfilePlot(options) {
    options = options || {};
    this.smoothed_data = options.data.smoothed || null;
    this.original_data = options.data.original || null;
    this.target = options.target || $("body");
    this.height = options.height || 130;
    this.smoothed = options.smoothed || true;
    this.leftMargin = 30;
    this.bottomMargin = 30;
    this.data = function() {
      if (this.smoothed) {
        return this.smoothed_data;
      }
      return this.original_data;
    };
    this.width = options.width || this.data()[0].length;
    this.render = function() {
      this.canvas = Raphael(this.target.get(0), this.width, this.height);
      this.draw_axes();
      this.draw_labels();
      this.draw_identity();
      this.draw_coverage();
      this.draw_similarity();
      var self = this;
      var marker = this.canvas.set();
      marker.push(this.canvas.circle(-100, this.height - 20, 10).attr({
        stroke: "#666",
        fill: "#fff"
      }), this.canvas.text(-100, this.height - 20, "1"));
      var crosshair = this.canvas.rect(-100, 0, 1, this.height - this.bottomMargin).attr({
        fill: "#666",
        "stroke-opacity": 0
      });
      this.canvas.rect(0, 0, this.width, this.height).attr({
        opacity: 0,
        fill: "#fff"
      }).mousemove(function(e) {
        if (e.layerX > self.leftMargin) {
          //work out the position for the label
          var text = scale(e.layerX - self.leftMargin, self.width - self.leftMargin, self.data()[0].length);
          marker.attr({
            x: e.layerX,
            cx: e.layerX,
            text: Math.round(text)
          });
          crosshair.attr({
            x: e.layerX
          });
          $("svg").trigger("coverage.move", [ text ]);
        } else {
          marker.attr({
            x: -100,
            cx: -100
          });
          crosshair.attr({
            x: -100
          });
        }
      }).mouseout(function() {
        marker.attr({
          x: -100,
          cx: -100
        });
        crosshair.attr({
          x: -100
        });
        $("svg").trigger("coverage.move", [ -1e3 ]);
      });
      var toggle_data = $(this.target).find(".toggle_data");
      if (toggle_data.length) {
        toggle_data.on("click", function() {
          if (self.smoothed) {
            self.smoothed = false;
            $(this).text("smoothed");
          } else {
            self.smoothed = true;
            $(this).text("raw");
          }
          self.target.find("svg").remove();
          $(this).off("click");
          self.render();
        });
      }
      $(this.target).find(".close").on("click", function() {
        $(this).parent().hide();
        $("#heatmaps").show();
      });
    };
    var pathFromData = function(data, self) {
      var prevX = null;
      var prevY = null;
      var path = "";
      data.forEach(function(datum, i) {
        var y = self.height - Math.round(100 * datum) - self.bottomMargin;
        var x = scale(i, data.length, self.width - self.leftMargin);
        if (i === 0) {
          path = "M" + (x + self.leftMargin) + "," + y;
        } else {
          if (prevX) {
            path = path + "L" + (prevX + self.leftMargin) + "," + prevY;
          }
          prevX = x;
          prevY = y;
        }
      });
      return path;
    };
    this.draw_coverage = function() {
      this.canvas.path(pathFromData(this.data()[0], this)).attr({
        stroke: "#900"
      });
    };
    this.draw_similarity = function() {
      this.canvas.path(pathFromData(this.data()[1], this)).attr({
        stroke: "#009"
      });
    };
    this.draw_identity = function() {
      var self = this;
      var prevX = null;
      var prevY = null;
      var data = self.data()[2];
      var path = data.reduce(function(path, datum, i, data) {
        var y = self.height - Math.round(100 * datum) - self.bottomMargin;
        var x = scale(i, data.length, self.width - self.leftMargin);
        var pathChunk = "L" + (prevX + self.leftMargin) + "," + prevY;
        prevX = x;
        prevY = y;
        return path + pathChunk;
      }, "M" + self.leftMargin + "," + (self.height - self.bottomMargin));
      // final line so the fill runs along the bottom of the graph
            path += "L" + (prevX + self.leftMargin) + "," + (self.height - self.bottomMargin);
      this.canvas.path(path).attr({
        stroke: "#999",
        fill: "#ccc"
      });
    };
    this.draw_labels = function() {
      //draw y-min
      this.canvas.text(this.leftMargin - 4, this.height - this.bottomMargin, "0").attr({
        "text-anchor": "end"
      });
      // draw x-min
            this.canvas.text(this.leftMargin, this.height - (this.bottomMargin - 10), "1");
      //draw x-max
            var x_max_label = this.canvas.text(this.width, this.height - (this.bottomMargin - 10), this.data()[0].length).attr({
        "text-anchor": "end"
      });
      this.canvas.path(this.line_string(this.width - 1, this.height - this.bottomMargin, this.width - 1, this.height - (this.bottomMargin - 3)));
      //draw y-max
            var x_max_left = this.width - x_max_label.getBBox().width;
      var y_max_bottom = 10;
      this.canvas.text(this.leftMargin - 4, 4, 100).attr({
        "text-anchor": "end"
      });
      this.canvas.path(this.line_string(this.leftMargin, 1, this.leftMargin - 3, 1));
      //draw y-ticks
            var y_ticks = nice_bounds(0, parseInt(100, 10), 5);
      var y_start = y_ticks.steps;
      for (var y_start = y_ticks.steps; y_start < y_ticks.max; y_start += y_ticks.steps) {
        var y = this.height - scale(y_start, 100, this.height - this.bottomMargin) - this.bottomMargin;
        if (y <= y_max_bottom) {
          break;
        }
        var x = this.leftMargin;
        this.canvas.path(this.line_string(x, y, x - 3, y));
        this.canvas.text(x - 4, y, y_start).attr({
          "text-anchor": "end"
        });
      }
      //draw x-ticks
            var x_ticks = nice_bounds(0, parseInt(this.data()[0].length), 10);
      var x_start = x_ticks.steps;
      for (var x_start = x_ticks.steps; x_start < x_ticks.max; x_start += x_ticks.steps) {
        var x = scale(x_start, this.data()[0].length, this.width - this.leftMargin) + this.leftMargin;
        var text = this.canvas.text(-100, -100, x_start);
        var text_width = text.getBBox().width;
        var x_right = x + text_width / 2;
        if (x_right >= x_max_left) {
          break;
        }
        var y = this.height - this.bottomMargin;
        this.canvas.path(this.line_string(x, y, x, y + 3));
        this.canvas.text(x, y + 10, x_start);
      }
    };
    this.line_string = function(x1, y1, x2, y2) {
      return "M" + x1 + "," + y1 + "L" + x2 + "," + y2;
    };
    this.draw_axes = function() {
      // y-axis
      var ypath = "M" + this.leftMargin + "," + 0 + "L" + this.leftMargin + "," + (this.height - (this.bottomMargin - 3));
      this.canvas.path(ypath);
      this.canvas.text(0, (this.height - this.bottomMargin) / 2, "Percent").transform("r-90t0,10");
      // x-axis
            var xpath = "M" + (this.leftMargin - 3) + "," + (this.height - this.bottomMargin) + "L" + (this.leftMargin + this.width) + "," + (this.height - this.bottomMargin);
      this.canvas.path(xpath);
      this.canvas.text(this.width / 2 + this.leftMargin / 2, this.height - this.bottomMargin + 22, "Position");
    };
  }
  $.fn.coveragePlot = function(data, width) {
    var plot = new HitProfilePlot({
      data: data,
      target: $(this),
      width: width
    });
    plot.render();
    return plot;
  };
  $.fn.similarityHeatMap = function(data) {
    var plot = new HeatMap({
      type: "similarity",
      data: data,
      target: $(this)
    });
    plot.render();
    plot.resize($("#domGraph").parent().width());
    return plot;
  };
  function HeatMap(options) {
    options = options || {};
    this.data = options.data.smoothed || null;
    this.type = options.type || "coverage";
    this.target = options.target || $("body");
    this.height = options.height || 20;
    this.leftMargin = 100;
    this.residueWidth = .5;
    this.seq_length = Math.ceil(this.data[0].length * this.residueWidth);
    this.width = this.seq_length + 2 + this.leftMargin;
    this.render = function() {
      var residueWidth = this.residueWidth;
      // Fragment with all of the heatmap line
            var fragment = document.createDocumentFragment();
      // Text description of the heatmap
            var span = document.createElement("span");
      span.textContent = "hit " + this.type;
      fragment.appendChild(span);
      // Actual heatmap, in a canvas
            var canvas = document.createElement("canvas");
      // Just one line
            canvas.width = this.data[0].length;
      canvas.height = 1;
      // That we stretch vertically and fit horizontally into the wanted size
            canvas.style.width = this.seq_length + "px";
      canvas.style.height = this.height + "px";
      // Mouse event listeners
      // SVG where the cursor will move
            var domains = $("svg");
      // Bounding box information, that we will cache to avoid repaints
            var bb;
      canvas.addEventListener("mousemove", function(e) {
        // First time over, calculate position of canvas
        if (!bb) {
          bb = canvas.getBoundingClientRect();
        }
        domains.trigger("coverage.move", [ (e.clientX - bb.left) / residueWidth ]);
      });
      canvas.addEventListener("mouseout", function() {
        // Reset the bounding box data when out, because it might move.
        bb = null;
        domains.trigger("coverage.move", [ -1e3 ]);
      });
      fragment.appendChild(canvas);
      this.canvas2d = canvas;
      this.draw_heatpoints();
      // Append everything to DOM
            var target = this.target[0];
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(function() {
          target.appendChild(fragment);
        });
      } else {
        target.appendChild(fragment);
      }
    };
    this.resize = function(width, height) {
      if (width > this.width) return;
      if (!width) {
        width = this.width;
      }
      if (!height) {
        height = this.height;
      }
      var seq_length = this.seq_length * this.residueWidth + this.leftMargin + 640;
      this.canvas.setSize(width, height);
      this.canvas.setViewBox(0, 0, seq_length, height);
      return this;
    };
    this.draw_labels = function() {
      // seq length label - hidden for now as other elements on the page
      // already show it. Might want to make it visible later.
      var len_label = this.canvas.text(0, 0, this.data[0].length).attr({
        opacity: 0
      });
      // now resize the canvas to fit the right label width
            var lwidth = len_label.getBBox().width;
      this.canvas.setSize(this.width + lwidth, this.height);
      // left label
            this.canvas.text(this.leftMargin / 2, this.height / 2, "hit " + this.type);
    };
    this.draw_heatpoints = function() {
      /* loop over the data and draw a colored stripe for each point
        based on its percentage */
      var data = this.data[this.type === "coverage" ? 0 : 1];
      var ctx = this.canvas2d.getContext("2d");
      var imgData = ctx.getImageData(0, 0, data.length, 1);
      var ta32 = new Int32Array(imgData.data.buffer);
      var red = 0 << 16 | 0 << 8 | 153;
      data.forEach(function(datum, i) {
        // alpha, blue, green, red
        ta32[i] = 255 * datum << 24 | red;
      });
      ctx.putImageData(imgData, 0, 0);
    };
  }
  $.fn.coverageHeatMap = function(data) {
    var plot = new HeatMap({
      type: "coverage",
      data: data,
      target: $(this)
    });
    plot.render();
    plot.resize($("#domGraph").parent().width());
  };
})(jQuery);

(function($) {
  "use strict";
  var seqAttrs = {
    fill: "#aaa",
    stroke: "#aaa",
    "stroke-width": 0
  };
  var hilight = {
    fill: "#fff",
    "stroke-width": 0,
    opacity: "0.2"
  };
  var hitAttrs = {
    stroke: "#000",
    "stroke-width": .5
  };
  var colors = [ "#900", "#f9ea6d", "#090", "#009" ];
  var width = 150;
  var height = 14;
  var adjustScale = function(data) {
    var scaled = $.extend(true, {}, data);
    /* need to scale the sequences. find the longest and make that = 100%
    then scale the second sequence accordingly.
    */    var seqs = [ data.target.len, data.query.len ];
    var longest = Math.max.apply(Math, seqs);
    for (var seq in data) {
      scaled[seq].len = Math.round(data[seq].len * width / longest);
      for (var hit in data[seq].hits) {
        scaled[seq].hits[hit][0] = Math.round((data[seq].hits[hit][0] - 1) * width / longest);
        scaled[seq].hits[hit][1] = Math.round((data[seq].hits[hit][1] - 1) * width / longest);
      }
    }
    return scaled;
  };
  var drawHit = function(canvas, hit, y) {
    var width = hit[1] - hit[0] + 1;
    var attribs = $.extend(hitAttrs, {
      fill: colors[hit[2]]
    });
    canvas.rect(hit[0], y, width, 4).attr(attribs);
    canvas.rect(hit[0], y, width, 2).attr(hilight);
  };
  $.fn.hitLocation = function(data, debug) {
    return this.each(function(i) {
      var scaled = adjustScale(data[i]);
      var canvas = Raphael(this, width, height);
      //draw the target/query sequences
            canvas.rect(0, 3, scaled.query.len, 2).attr(seqAttrs);
      canvas.rect(0, 9, scaled.target.len, 2).attr(seqAttrs);
      //draw the matches on the query
            for (var hit in scaled.query.hits) {
        drawHit(canvas, scaled.query.hits[hit], 2);
      }
      //draw the matches on the target
      for (var hit in scaled.target.hits) {
        drawHit(canvas, scaled.target.hits[hit], 8);
      }
      if (debug) {
        for (var i = 0; i <= width; i += 2) {
          canvas.rect(i, 0, 1, 14).attr({
            fill: "#000",
            "stroke-width": 0,
            opacity: .1
          });
        }
        for (var i = 0; i <= height; i += 2) {
          canvas.rect(0, i, width, 1).attr({
            fill: "#000",
            "stroke-width": 0,
            opacity: .1
          });
        }
      }
    });
  };
})(jQuery);

(function($) {
  "use strict";
  function HMMLogo(options) {
    options = options || {};
    this.column_width = options.column_width || 34;
    this.height = options.height || 300;
    this.data = options.data || null;
    this.scale_height_enabled = options.height_toggle || null;
    if (options.zoom_buttons && options.zoom_buttons === "disabled") {
      this.zoom_enabled = null;
    } else {
      this.zoom_enabled = true;
    }
    this.alphabet = options.alphabet || "dna";
    this.dom_element = options.dom_element || $("body");
    this.start = options.start || 1;
    this.end = options.end || this.data.height_arr.length;
    this.zoom = parseFloat(options.zoom) || .4;
    this.default_zoom = this.zoom;
    this.data.max_height = options.data[options.scaled_max ? "max_height_obs" : "max_height_theory"] || this.data.max_height || 2;
    this.dna_colors = {
      A: "#cbf751",
      C: "#5ec0cc",
      G: "#ffdf59",
      T: "#b51f16",
      U: "#b51f16"
    };
    this.aa_colors = {
      A: "#FF9966",
      C: "#009999",
      D: "#FF0000",
      E: "#CC0033",
      F: "#00FF00",
      G: "#f2f20c",
      H: "#660033",
      I: "#CC9933",
      K: "#663300",
      L: "#FF9933",
      M: "#CC99CC",
      N: "#336666",
      P: "#0099FF",
      Q: "#6666CC",
      R: "#990000",
      S: "#0000FF",
      T: "#00FFFF",
      V: "#FFCC33",
      W: "#66CC66",
      Y: "#006600"
    };
    // set the color library to use.
        this.colors = this.dna_colors;
    if (this.alphabet === "aa") {
      this.colors = this.aa_colors;
    }
    this.canvas_width = 5e3;
    // this needs to be set to null here so that we can initialise it after
    // the render function has fired and the width determined.
        this.scrollme = null;
    this.previous_target = 0;
    // keeps track of which canvas elements have been drawn
    // and which ones haven't.
        this.rendered = [];
    this.previous_zoom = 0;
    // the main render function that draws the logo based on
    // the provided options.
        this.render = function(options) {
      if (!this.data) {
        return;
      }
      options = options || {};
      var zoom = Math.min(1, Math.max(.1, options.zoom || this.zoom));
      var target = options.target || 1;
      if (target === this.previous_target) {
        return;
      }
      this.previous_target = target;
      if (options.start) {
        this.start = options.start;
      }
      if (options.end) {
        this.end = options.end;
      }
      var end = this.end || this.data.height_arr.length;
      end = end > this.data.height_arr.length ? this.data.height_arr.length : end;
      end = Math.max(end, this.start);
      var start = Math.min(Math.min(this.start || 1, end), 1);
      this.y = this.height - 20;
      // Check to see if the logo will fit on the screen at full zoom.
            this.max_width = this.column_width * (end - start + 1);
      var parent_width = $(this.dom_element).parent().width();
      // If it fits then zoom out and disable zooming.
            if (parent_width > this.max_width) {
        zoom = 1;
        this.zoom_enabled = false;
      }
      this.zoom = zoom;
      this.zoomed_column = this.column_width * zoom;
      this.total_width = this.zoomed_column * (end - start + 1);
      // If zoom is not maxed and we still aren't filling the window
      // then ramp up the zoom level until it fits, then disable zooming.
      // Then we get a decent logo with out needing to zoom in or out.
            if (zoom < 1) {
        while (this.total_width < parent_width) {
          this.zoom += .1;
          this.zoomed_column = this.column_width * this.zoom;
          this.total_width = this.zoomed_column * (end - start + 1);
          this.zoom_enabled = false;
          if (zoom >= 1) {
            break;
          }
        }
      }
      if (target > this.total_width) {
        target = this.total_width;
      }
      $(this.dom_element).attr({
        width: this.total_width + "px"
      }).css({
        width: this.total_width + "px"
      });
      var canvas_count = Math.ceil(this.total_width / this.canvas_width);
      this.columns_per_canvas = Math.ceil(this.canvas_width / this.zoomed_column);
      if (this.previous_zoom !== this.zoom) {
        $(this.dom_element).find("canvas").remove();
        this.previous_zoom = this.zoom;
        this.rendered = [];
      }
      this.canvases = [];
      this.contexts = [];
      var max_canvas_width = 1;
      for (var i = 0; i < canvas_count; i++) {
        var split_start = this.columns_per_canvas * i + start;
        var split_end = split_start + this.columns_per_canvas - 1;
        if (split_end > end) {
          split_end = end;
        }
        var adjusted_width = (split_end - split_start + 1) * this.zoomed_column;
        if (adjusted_width > max_canvas_width) {
          max_canvas_width = adjusted_width;
        }
        var canv_start = max_canvas_width * i;
        var canv_end = canv_start + adjusted_width;
        if (target < canv_end + canv_end / 2 && target > canv_start - canv_start / 2) {
          // Check that we aren't redrawing the canvas and if not,
          // then attach it and draw.
          if (this.rendered[i] !== 1) {
            this.canvases[i] = attach_canvas(this.dom_element, this.height, adjusted_width, i, max_canvas_width);
            this.contexts[i] = this.canvases[i].getContext("2d");
            this.contexts[i].setTransform(1, 0, 0, 1, 0, 0);
            this.contexts[i].clearRect(0, 0, adjusted_width, this.height);
            this.contexts[i].fillStyle = "#fff";
            this.contexts[i].fillRect(0, 0, canv_end, this.height);
            if (this.zoomed_column > 12) {
              var fontsize = parseInt(10 * this.zoom, 10);
              fontsize = Math.min(fontsize, 10);
              this.render_with_text(split_start, split_end, i, fontsize);
            } else {
              this.render_with_rects(split_start, split_end, i);
            }
            this.rendered[i] = 1;
          }
        }
      }
      // check if the scroller object has been initialised and if not do so.
      // we do this here as opposed to at object creation, because we need to
      // make sure the logo has been rendered and the width is correct,
      // otherwise we get a weird initial state where the canvas will bounce
      // back to the beginning the first time it is scrolled, because it thinks
      // it has a width of 0.
            if (!this.scrollme) {
        this.scrollme = new EasyScroller($(this.dom_element)[0], {
          scrollingX: 1,
          scrollingY: 0
        });
      }
      if (target !== 1) {
        this.scrollme.reflow();
      }
    };
    this.render_x_axis = function() {
      $(this.dom_element).parent().before('<p id="logo_xaxis" class="centered" style="margin-left:40px">' + "Model Position</p>");
    };
    this.render_y_axis = function() {
      //attach a canvas for the y-axis
      $(this.dom_element).parent().before('<canvas id="logo_yaxis" class="logo_yaxis" height="300" width="40">' + "</canvas>");
      var canvas = $("#logo_yaxis");
      var context = canvas[0].getContext("2d");
      //draw tick marks
            context.beginPath();
      context.moveTo(40, 1);
      context.lineTo(30, 1);
      context.moveTo(40, 271);
      context.lineTo(30, 271);
      context.moveTo(40, 271 / 2);
      context.lineTo(30, 271 / 2);
      context.lineWidth = 1;
      context.strokeStyle = "#666";
      context.stroke();
      context.fillStyle = "#000";
      context.textAlign = "right";
      context.font = "bold 10px Arial";
      context.textBaseline = "top";
      context.fillText(parseFloat(this.data.max_height).toFixed(1), 28, 0);
      context.textBaseline = "middle";
      context.fillText(parseFloat(this.data.max_height / 2).toFixed(1), 28, 271 / 2);
      context.fillText("0", 28, 271);
      // draw the label
            context.save();
      context.translate(10, this.height / 2);
      context.rotate(-Math.PI / 2);
      context.textAlign = "center";
      context.font = "normal 12px Arial";
      context.fillText("Information Content", 1, 0);
      context.restore();
    };
    this.render_x_axis();
    this.render_y_axis();
    this.render_with_text = function(start, end, context_num, fontsize) {
      var x = 0;
      var column_num = start;
      // add 3 extra columns so that numbers don't get clipped at the end of a
      // canvas that ends before a large column. DF0000830 was suffering at
      // zoom level 0.6, column 2215. This adds a little extra overhead,
      // but is the easiest fix for now.
            if (end + 3 <= this.end) {
        end += 3;
      }
      for (var i = start; i <= end; i++) {
        if (this.data.mmline && this.data.mmline[i - 1] === 1) {
          this.contexts[context_num].fillStyle = "#cccccc";
          this.contexts[context_num].fillRect(x, 10, this.zoomed_column, this.height - 40);
        } else {
          var column = this.data.height_arr[i - 1];
          if (column) {
            var previous_height = 0;
            var letters = column.length;
            for (var j = 0; j < letters; j++) {
              var letter = column[j];
              var values = letter.split(":", 2);
              if (values[1] > .01) {
                var letter_height = 1 * values[1] / this.data.max_height;
                var x_pos = x + this.zoomed_column / 2;
                var y_pos = 269 - previous_height;
                var glyph_height = 258 * letter_height;
                this.contexts[context_num].font = "bold 350px Arial";
                this.contexts[context_num].textAlign = "center";
                this.contexts[context_num].fillStyle = this.colors[values[0]];
                // fonts are scaled to fit into the column width
                // formula is y = 0.0024 * col_width + 0.0405
                                this.contexts[context_num].transform((.0024 * this.zoomed_column + .0405).toFixed(2), 0, 0, letter_height, x_pos, y_pos);
                this.contexts[context_num].fillText(values[0], 0, 0);
                this.contexts[context_num].setTransform(1, 0, 0, 1, 0, 0);
                previous_height = previous_height + glyph_height;
              }
            }
          }
        }
        //draw insert length ticks
                draw_ticks(this.contexts[context_num], x, this.height - 15, 5);
        // draw insert probability ticks
                draw_ticks(this.contexts[context_num], x, this.height - 30, 5);
        if (this.zoom < .7) {
          if (i % 5 === 0) {
            // draw column dividers
            draw_ticks(this.contexts[context_num], x + this.zoomed_column, this.height - 30, -this.height - 30, "#dddddd");
            // draw top ticks
                        draw_ticks(this.contexts[context_num], x + this.zoomed_column, 0, 5);
            // draw column numbers
                        draw_column_number(this.contexts[context_num], x + 2, 10, this.zoomed_column, column_num, 10, true);
          }
        } else {
          // draw column dividers
          draw_ticks(this.contexts[context_num], x, this.height - 30, 0 - this.height - 30, "#dddddd");
          // draw top ticks
                    draw_ticks(this.contexts[context_num], x, 0, 5);
          // draw column numbers
                    draw_column_number(this.contexts[context_num], x, 10, this.zoomed_column, column_num, fontsize);
        }
        draw_insert_odds(this.contexts[context_num], x, this.height, this.zoomed_column, this.data.insert_probs[i - 1] / 100, fontsize);
        draw_insert_length(this.contexts[context_num], x, this.height - 5, this.zoomed_column, this.data.insert_lengths[i - 1], fontsize);
        x += this.zoomed_column;
        column_num++;
      }
      draw_border(this.contexts[context_num], this.height - 15, this.total_width);
      draw_border(this.contexts[context_num], this.height - 30, this.total_width);
      draw_border(this.contexts[context_num], 0, this.total_width);
    };
    this.render_with_rects = function(start, end, context_num) {
      var x = 0;
      var column_num = start;
      for (var i = start; i <= end; i++) {
        if (this.data.mmline && this.data.mmline[i - 1] === 1) {
          this.contexts[context_num].fillStyle = "#ccc";
          this.contexts[context_num].fillRect(x, 10, this.zoomed_column, this.height - 40);
        } else {
          var column = this.data.height_arr[i - 1];
          var previous_height = 0;
          var letters = column.length;
          for (var j = 0; j < letters; j++) {
            var letter = column[j];
            var values = letter.split(":", 2);
            if (values[1] > .01) {
              var letter_height = 1 * values[1] / this.data.max_height;
              var x_pos = x;
              var glyph_height = 258 * letter_height;
              var y_pos = 269 - previous_height - glyph_height;
              this.contexts[context_num].fillStyle = this.colors[values[0]];
              this.contexts[context_num].fillRect(x_pos, y_pos, this.zoomed_column, glyph_height);
              previous_height = previous_height + glyph_height;
            }
          }
        }
        var mod = 10;
        if (this.zoom < .2) {
          mod = 20;
        } else if (this.zoom < .3) {
          mod = 10;
        }
        if (i % mod === 0) {
          // draw column dividers
          draw_ticks(this.contexts[context_num], x + this.zoomed_column, this.height - 30, 0 - this.height, "#dddddd");
          // draw top ticks
                    draw_ticks(this.contexts[context_num], x + this.zoomed_column, 0, 5);
          // draw column numbers
                    draw_column_number(this.contexts[context_num], x - 2, 10, this.zoomed_column, column_num, 10, true);
        }
        // draw insert probabilities/lengths
                draw_small_insert(this.contexts[context_num], x, this.height - 28, this.zoomed_column, this.data.insert_probs[i - 1] / 100, this.data.insert_lengths[i - 1]);
        x += this.zoomed_column;
        column_num++;
      }
    };
    this.toggle_scale = function() {
      // work out the current column we are on so we can return there
      var before_left = this.scrollme.scroller.getValues().left;
      var col_width = this.column_width * this.zoom;
      var col_count = before_left / col_width;
      var half_visible_columns = $("#logo_container").width() / col_width / 2;
      var col_total = Math.ceil(col_count + half_visible_columns);
      // toggle the max height
            if (this.data.max_height === this.data.max_height_obs) {
        this.data.max_height = this.data.max_height_theory;
      } else {
        this.data.max_height = this.data.max_height_obs;
      }
      // reset the redered counter so that each section will re-render
      // with the new heights
            this.rendered = [];
      //update the y-axis
            $("#logo_yaxis").remove();
      this.render_y_axis();
      // re-flow and re-render the content
            this.scrollme.reflow();
      //scroll off by one to force a render of the canvas.
            this.scrollToColumn(col_total + 1);
      //scroll back to the location we started at.
            this.scrollToColumn(col_total);
    };
    this.change_zoom = function(options) {
      var zoom_level = .3;
      if (options.target) {
        zoom_level = options.target;
      } else if (options.distance) {
        zoom_level = (parseFloat(this.zoom) - parseFloat(options.distance)).toFixed(1);
        if (options.direction === "+") {
          zoom_level = (parseFloat(this.zoom) + parseFloat(options.distance)).toFixed(1);
        }
      }
      if (zoom_level > 1) {
        zoom_level = 1;
      } else if (zoom_level < .1) {
        zoom_level = .1;
      }
      // see if we need to zoom or not
            var expected_width = $("#logo_graphic").width() * zoom_level / this.zoom;
      if (expected_width > $("#logo_container").width()) {
        //work out my current position
        var before_left = this.scrollme.scroller.getValues().left;
        var col_width = this.column_width * this.zoom;
        var col_count = before_left / col_width;
        var half_visible_columns = $("#logo_container").width() / col_width / 2;
        var col_total = Math.ceil(col_count + half_visible_columns);
        this.zoom = zoom_level;
        this.render({
          zoom: this.zoom
        });
        this.scrollme.reflow();
        //scroll to previous position
                this.scrollToColumn(col_total);
      }
      return this.zoom;
    };
    this.scrollToColumn = function(num, animate) {
      var half_view = $("#logo_container").width() / 2 - this.column_width * this.zoom / 2;
      var new_column = num - 1;
      var new_left = new_column * (this.column_width * this.zoom);
      this.scrollme.scroller.scrollTo(new_left - half_view, 0, animate);
    };
    function draw_small_insert(context, x, y, col_width, odds, length) {
      var fill = "#fff";
      if (odds > .4) {
        fill = "#d7301f";
      } else if (odds > .3) {
        fill = "#fc8d59";
      } else if (odds > .2) {
        fill = "#fdcc8a";
      } else if (odds > .1) {
        fill = "#fef0d9";
      }
      context.fillStyle = fill;
      context.fillRect(x, y, col_width, 10);
      fill = "#fff";
      // draw insert length
            if (length > 99) {
        fill = "#2171b5";
      } else if (length > 49) {
        fill = "#6baed6";
      } else if (length > 9) {
        fill = "#bdd7e7";
      }
      context.fillStyle = fill;
      context.fillRect(x, y + 12, col_width, 10);
    }
    function draw_border(context, y, width) {
      context.beginPath();
      context.moveTo(0, y);
      context.lineTo(width, y);
      context.lineWidth = 1;
      context.strokeStyle = "#999";
      context.stroke();
    }
    function draw_insert_odds(context, x, height, col_width, text, fontsize) {
      var y = height - 20;
      var fill = "#fff";
      var textfill = "#000";
      if (text > .4) {
        fill = "#d7301f";
        textfill = "#fff";
      } else if (text > .3) {
        fill = "#fc8d59";
      } else if (text > .2) {
        fill = "#fdcc8a";
      } else if (text > .1) {
        fill = "#fef0d9";
      }
      context.font = fontsize + "px Arial";
      context.fillStyle = fill;
      context.fillRect(x, y - 10, col_width, 14);
      context.textAlign = "center";
      context.fillStyle = textfill;
      context.fillText(text, x + col_width / 2, y);
      //draw vertical line to indicate where the insert would occur
            if (text > .1) {
        draw_ticks(context, x + col_width, height - 30, 0 - height - 30, fill);
      }
    }
    function draw_insert_length(context, x, y, col_width, text, fontsize) {
      var fill = "#fff";
      var textfill = "#000";
      if (text > 99) {
        fill = "#2171b5";
        textfill = "#fff";
      } else if (text > 49) {
        fill = "#6baed6";
      } else if (text > 9) {
        fill = "#bdd7e7";
      }
      context.font = fontsize + "px Arial";
      context.fillStyle = fill;
      context.fillRect(x, y - 10, col_width, 14);
      context.textAlign = "center";
      context.fillStyle = textfill;
      context.fillText(text, x + col_width / 2, y);
    }
    function draw_column_number(context, x, y, col_width, col_num, fontsize, right) {
      context.font = fontsize + "px Arial";
      context.textAlign = right ? "right" : "center";
      context.fillStyle = "#666";
      context.fillText(col_num, x + col_width / 2, y);
    }
    function draw_ticks(context, x, y, height, color) {
      color = color || "#999";
      context.beginPath();
      context.moveTo(x, y);
      context.lineTo(x, y + height);
      context.strokeStyle = color;
      context.stroke();
    }
    function attach_canvas(DOMid, height, width, id, canv_width) {
      var canvas = $(DOMid).find("#canv_" + id);
      if (!canvas.length) {
        $(DOMid).append('<canvas class="canvas_logo" id="canv_' + id + '"  height="' + height + '" width="' + width + '" style="left:' + canv_width * id + 'px"></canvas>');
        canvas = $(DOMid).find("#canv_" + id);
      }
      $(canvas).attr("width", width).attr("height", height);
      return canvas[0];
    }
  }
  $.fn.hmm_logo = function(options) {
    options = options || {};
    options.dom_element = $(this);
    var logo = new HMMLogo(options);
    logo.render(options);
    var form = $("<form>");
    if (logo.scale_height_enabled) {
      form.append('<button id="scale" class="button">Scale Toggle</button><br/>');
    }
    $(this).parent().after('<label>Column number:<input type="number" min="1" step="1" max="' + logo.end + '" value="1" name="position" id="position"/></label>').after(form);
    if (logo.zoom_enabled) {
      form.append('<button id="zoomout" class="button">-</button>' + '<button id="zoomin" class="button">+</button>');
      $("#zoomin").on("click", function(e) {
        e.preventDefault();
        logo.change_zoom({
          distance: .1,
          direction: "+"
        });
      });
      $("#zoomout").on("click", function(e) {
        e.preventDefault();
        logo.change_zoom({
          distance: .1,
          direction: "-"
        });
      });
    }
    $("#scale").on("click", function(e) {
      e.preventDefault();
      logo.toggle_scale();
    });
    $("#position").on("input", function() {
      logo.scrollToColumn(Math.floor(this.value), 1);
    });
    $("#logo_graphic").on("dblclick", function(e) {
      // need to get coordinates, then scroll to location and zoom.
      var offset = $(this).offset();
      var x = parseInt(e.pageX - offset.left, 10);
      var half_viewport = $("#logo_container").width() / 2;
      logo.scrollme.scroller.scrollTo(x - half_viewport, 0, 0);
      logo.change_zoom({
        target: logo.zoom < 1 ? 1 : .3
      });
    });
    $(document).on("scrolledTo", function(e, left) {
      logo.render({
        target: left
      });
    });
    $(document).keydown(function(e) {
      if (!e.ctrlKey) {
        if (e.which === 61 || e.which === 107) {
          logo.change_zoom({
            distance: .1,
            direction: "+"
          });
        }
        if (e.which === 109 || e.which === 0) {
          logo.change_zoom({
            distance: .1,
            direction: "-"
          });
        }
      }
    });
  };
})(jQuery);

Handlebars.registerHelper("twoSig", function(num, digits) {
  return parseFloat(num).toFixed(digits);
});

Handlebars.registerHelper("regions", function(segments) {
  return segments.reduce(function(accumulated, segment) {
    return accumulated + ", " + segment.start + "-" + segment.end;
  }, "").substr(2);
});

/********************************************************************
Used to build the taxonomy filter for Hmmerweb
********************************************************************/
var site_url = document.location.origin + "/";

var pathname = document.location.pathname;

var reg = /Tools\/hmmer/;

var match = pathname.match(reg);

if (match) site_url = document.location.origin + "/Tools/hmmer/";

(function($, global) {
  "use strict";
  /*************************************************
   Tax Filter Tree
  *************************************************/
  /* represents a branch or leaf */  var TaxNodeItem = function(parent, item) {
    this.init(parent, item);
  };
  TaxNodeItem.prototype = {
    constructor: TaxNodeItem,
    init: function(parent, item) {
      var node;
      var node_name;
      this.short_name = item.short;
      this.long_name = item.long;
      this.ncbi = item.ncbi;
      this.complete = item.complete;
      //create this node
            node = $("<li>").addClass("taxNodeItem");
      //add "check box"
            var cb_id = "cb_" + this.ncbi;
      this.checkbox = $('<input id="' + cb_id + '" type="checkbox" name="taxfilter" class="taxfilter_selection">');
      $(this.checkbox).val(this.ncbi);
      $(this.checkbox).on("click", this.do_checkbox_change);
      node.append(this.checkbox);
      var label = $("<label>").attr("for", cb_id);
      label.append($("<span>").addClass("check_image"));
      var tooltip_data = this.long_name + '(taxid: <a class="ext" title="Link to taxonomy browser on NCBI site"' + ' href="http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=' + this.ncbi + '">' + this.ncbi + "</a>)";
      node_name = $("<span>").addClass("nodeName").html(this.short_name);
      label.attr("data-popover_data", tooltip_data);
      label.append(node_name);
      node.append(label);
      //add children
            if (item.children) {
        //add node
        node.append(new TaxNode(node, item.children));
        //add the "+/-"
                $(node).prepend('<div class="expandable_marker more"></div>');
      } else {
        $(node).addClass("noChildren");
      }
      //add events & triggers
            $(node).children("div").on("click", this.do_toggle);
      $(node).children("ul").hide();
      $(parent).append(node);
    },
    do_toggle: function() {
      var parent_li = $(this).parent();
      var children = $(this).siblings("ul");
      //stop from collapsing if no child node
            if (!children.length) return;
      //set the class on the expandable marker span
            var marker_span = $(parent_li).find("div:first");
      if ($(marker_span).hasClass("more")) {
        $(marker_span).removeClass("more").addClass("less");
      } else {
        $(marker_span).removeClass("less").addClass("more");
      }
      //show/hide this nodes children
            $(children).toggle("slide");
      //show/hide this nodes parent's (the li) siblings
            $(this).parent().siblings("li").toggle("slide");
      //Reset decendent nodes (clears tree nav history)
            $(children).find("li").show();
      $(children).find("ul").hide();
      $(children).find("div.less").removeClass("less").addClass("more");
    },
    do_checkbox_change: function() {
      // clear partial_check classes for this branch
      // (if we are selecting or deselecting,
      // all leaf nodes will be in same state)
      $(this).parent().find("input").removeClass("partial_check show_check");
      //set all decendents to same state
            $(this).parent().find("input").prop("checked", $(this).prop("checked"));
      //set checked class
            $(this).parent().find("input:checked").addClass("show_check");
      //check parent state
            $.fn.taxonomyTree.do_checkbox_parent_check(this);
      //update the selected items tracking...
            $(".taxTreeRoot").data("tax_tree").updateSelectedItems();
      //force IE to refresh the dom for the tree
            document.body.className = document.body.className;
    }
  };
  /* Tax Filter Tree Node */
  /* denotes a branch */  var TaxNode = function(parent, source) {
    this.init(parent, source);
  };
  TaxNode.prototype = {
    constructor: TaxNode,
    init: function(parent, source) {
      // options should contain an array of items
      var node = $("<ul>").addClass("taxNode");
      $.each(source, function(index, item) {
        new TaxNodeItem(node, item);
      });
      parent.append(node);
    }
  };
  /* Tax Filter Tree */
  /* container for all branch and leaf nodes */  var TaxonomyTree = function(element, options) {
    this.init(element, options);
  };
  TaxonomyTree.prototype = {
    constructor: TaxonomyTree,
    init: function(element, options) {
      this.type = "taxonomyTree";
      this.$element = $(element);
      this.options = this.getOptions(options);
      var element = this.$element;
      element.addClass("loading");
      this.options.source(function(data) {
        element.removeClass("loading");
        new TaxNode(element, data);
      });
    },
    getOptions: function(options) {
      return $.extend({}, $.fn.taxonomyTree.defaults, options);
    },
    reset: function() {
      //clear the check boxes
      this.$element.find("input").attr("checked", false);
      this.$element.find("input").removeClass("partial_check show_check");
      //collapse the tree
      //Reset decendent nodes (clears tree nav history)
            this.$element.find("ul:first").find("li").show();
      this.$element.find("ul:first").find("ul").hide();
      this.$element.find("ul:first").find("div.less").removeClass("less").addClass("more");
      //reset the arrows
            $("div.less").removeClass("more").addClass("less");
      this.updateSelectedItems();
    },
    updateSelectedItems: function() {
      $("#tax_included").val(this.get_ids_selected(this.$element));
    },
    get_ids_selected: function(node_ele) {
      var checkbox;
      var selected_ids = [];
      var that = this;
      $(node_ele).find("ul:first").children("li").each(function(index, item) {
        //check if it is checked.. add to array if is
        checkbox = $(item).find("input:checkbox:first");
        if (checkbox.is(":checked")) {
          selected_ids.push(checkbox.val());
        } else if (checkbox.hasClass("partial_check")) {
          selected_ids.push(that.get_ids_selected(item));
        }
      });
      return selected_ids.join();
    }
  };
  $.fn.taxonomyTree = function(options) {
    $(this).addClass("taxTreeRoot");
    $(this).data("tax_tree", new TaxonomyTree(this, options));
    //add tooltips to tree
        $(".taxNodeItem > label").each(function() {
      $(this).qtip({
        content: {
          text: $(this).attr("data-popover_data")
        },
        style: {
          tip: {
            corner: "left center"
          },
          classes: "ui-tooltip-hmmer ui-tooltip-rounded auto_width"
        },
        show: {
          solo: true,
          event: "mouseover"
        },
        hide: {
          fixed: true,
          delay: 1e3,
          event: "mouseout"
        },
        position: {
          at: "center right",
          my: "center left",
          target: $(this)
        }
      });
    });
  };
  $.fn.taxonomyTree.defaults = {
    source: []
  };
  $.fn.taxonomyTree.do_checkbox_parent_check = function(current_node) {
    var this_li = $(current_node).parent();
    var this_ul = $(this_li).parent();
    var parent_li = $(this_ul).parent();
    var parent_checkbox = $(parent_li).children("input");
    //check if parent node is in tree
        if (!$(parent_li).is("li")) return;
    //check if all items at this level are checked
    //set parent (checked &/ class)
        var count_checked = $(parent_li).find("ul input:checked").size();
    var total_checkboxes = $(parent_li).find("ul input").size();
    if (total_checkboxes === count_checked) {
      $(parent_checkbox).prop("checked", "checked");
      $(parent_checkbox).removeClass("partial_check").addClass("show_check");
    } else {
      $(parent_checkbox).prop("checked", "");
      if (count_checked > 0) {
        $(parent_checkbox).removeClass("show_check").addClass("partial_check");
      } else {
        $(parent_checkbox).removeClass("partial_check show_check");
      }
    }
    //do it again...
        $.fn.taxonomyTree.do_checkbox_parent_check(parent_checkbox);
  };
  /*************************************************************
  Tax filter lookup
  extends twitter bootstaps typeahead
  *************************************************************/  var TaxIdLookup = function(element, options) {
    /* duplicated from typeahead since type ahead does not impliment init */
    this.$element = $(element);
    this.options = $.extend({}, $.fn.typeahead.defaults, options);
    //this.options.item = '<li><span class='left'></span></li>'
        this.matcher = this.options.matcher || this.matcher;
    this.sorter = this.options.sorter || this.sorter;
    this.highlighter = this.options.highlighter || this.highlighter;
    this.updater = this.options.updater || this.updater;
    this.source = this.options.source;
    this.$menu = $(this.options.menu);
    this.shown = false;
    this.selected_items = [];
    this.base = null;
    // this.listen();
        this.number_selected = 0;
    this.options.max_selected = 10;
  };
  TaxIdLookup.prototype = $.extend({}, $.fn.typeahead.Constructor.prototype, {
    constructor: TaxIdLookup,
    reset: function() {
      this.selected_items = [];
      this.updateSelectedItems();
    },
    select: function() {
      this.includeItem();
      //clear the input box
            this.$element.val("").change();
      return this.hide();
    },
    process: function(items) {
      if (!items.length) return;
      if (this.number_selected >= this.options.max_selected) return;
      var that = this;
      items = items.filter(function(item) {
        return !that.base || item.lft >= that.base.lft && item.rgt <= that.base.rgt;
      });
      items.forEach(function(item) {
        item.displayName = item.name + ' <span class="taxid">(taxid: ' + item.taxid + ")</span>";
      });
      if (!items.length) {
        if (this.shown) {
          this.hide();
        }
        return;
      }
      var rendered = this.render(items);
      if (rendered) return rendered.show();
    },
    render: function(items) {
      var that = this;
      var inclusion;
      items = items.map(function(item) {
        //create the new item
        var i = $(that.options.item);
        //add the attributs
                i.attr("data-display_name", item.displayName);
        i.attr("data-taxid", item.taxid);
        i.attr("data-lft", item.lft);
        i.attr("data-rgt", item.rgt);
        i.attr("data-name", item.name);
        //set the class and parent_item attr
                inclusion = that.getInclusionItem(item.lft);
        var prefix = "";
        if (typeof inclusion !== "undefined") {
          i.attr("data-ancestor", inclusion);
          prefix = '<span class="before exclude">Exclude: </span>';
          i.addClass("exclusion");
        } else {
          i.addClass("inclusion");
          prefix = '<span class="before">Include: </span>';
        }
        //set the content
                i.find("a").html(prefix + item.displayName);
        return i[0];
      });
      items[0].classList.add("active");
      this.$menu.html(items);
      this.$menu.find("li span:first-child").on("click", $.proxy(this.click, this));
      return this;
    },
    getInclusionItem: function(lft) {
      //is this item included in previously selected?
      for (var i = 0; i < this.selected_items.length; i++) {
        if (parseInt(this.selected_items[i].lft, 10) <= parseInt(lft, 10) && parseInt(this.selected_items[i].rgt, 10) >= parseInt(lft, 10)) {
          return i;
        }
      }
    },
    getItemAttr: function(item, programmatically) {
      var ds = item.dataset || item;
      return {
        taxid: ds.taxid,
        lft: ds.lft,
        rgt: ds.rgt,
        name: ds.name,
        displayName: ds.display_name || ds.name + ' <span class="taxid">(taxid: ' + ds.taxid + ")</span>",
        inclusion: item.classList ? item.classList.contains("inclusion") : item.inclusion || false,
        ancestor: ds.ancestor,
        programmatically: programmatically
      };
    },
    includeItem: function(item, programmatically) {
      // Retrieve item attributes from whatever was passed
      var itemAttr = this.getItemAttr(item || document.querySelector("#taxfilter_content .active"), programmatically);
      var tempItems;
      var tempIndex = 0;
      if (this.base && (itemAttr.lft < this.base.rgt || itemAttr.rgt > this.base.lft)) {
        return;
      }
      // What would that be for?
      /* if (itemAttr.programmatically) {
        this.base = {lft: itemAttr.lft, rgt: itemAttr.rgt};
      } */
      //add to selected_items
            if (itemAttr.inclusion) {
        itemAttr.exclusions = [];
        //if inclusion, make sure we don't need to replace existing
        //find previously selected items(psi) covered by this item
                tempItems = this.selected_items;
        tempItems.forEach(function(psi) {
          if (parseInt(psi.lft, 10) >= parseInt(itemAttr.lft, 10) && parseInt(psi.rgt, 10) <= parseInt(itemAttr.rgt, 10)) {
            itemAttr.exclusions = itemAttr.exclusions.concat(psi.exclusions);
            tempItems.splice(tempIndex, 1);
            tempIndex--;
          } else {
            tempIndex++;
          }
        });
        tempItems.push(itemAttr);
      } else {
        //remove exclusions in new range
        tempItems = this.selected_items[itemAttr.ancestor].exclusions;
        tempItems.forEach(function(pse) {
          if (pse.lft >= itemAttr.lft && pse.rgt <= itemAttr.rgt) {
            tempItems.splice(tempIndex, 1);
            tempIndex--;
          } else {
            tempIndex++;
          }
        });
        tempItems.push(itemAttr);
      }
      //update the selected items display
            this.updateSelectedItems();
    },
    removeSelectedItems: function(taxId) {
      // If no ID passed, remove everything
      if (!taxId) {
        this.selected_items = [];
        this.base = null;
      } else {
        //remove item from this.selected_items
        var temp_items;
        var temp_items2;
        temp_items = this.selected_items;
        $(this.selected_items).each(function(index, item) {
          if (item.taxid == taxId) {
            temp_items.splice(index, 1);
            return;
          } else {
            temp_items2 = item.exclusions;
            $(item.exclusions).each(function(index2, item2) {
              if (item2.taxid == taxId) {
                temp_items2.splice(index2, 1);
                return;
              }
            });
            item.exclusions = temp_items2;
          }
        });
        this.selected_items = temp_items;
      }
      //update selected items display
            this.updateSelectedItems();
    },
    updateSelectedItems: function() {
      var parent_node;
      var child_node;
      var container;
      var content;
      var child_content;
      var exclusions;
      var excluded_child;
      var remove_link;
      var that = this;
      var included_ids = [];
      var excluded_ids = [];
      container = $("#selected_taxids");
      parent_node = "<ul>";
      child_node = "<li>";
      content = $(parent_node);
      $(this.selected_items).each(function(index, included_item) {
        content.append(function() {
          child_content = $(child_node);
          child_content.attr("data-taxid", included_item.taxid);
          child_content.append($("<span>" + included_item.displayName + "</span>"));
          var title_text = "Remove " + included_item.name + "";
          if (included_item.exclusions.length > 0) {
            title_text += " and its exclusions";
          }
          if (!included_item.programmatically) {
            remove_link = $('<a class="right remove" title="' + title_text + '"></a>').on("click", $.proxy(that.removeSelectedItems, that, included_item.taxid));
            child_content.append(remove_link);
          }
          included_ids.push(included_item.taxid);
          if (included_item.exclusions.length) {
            child_content.append(function() {
              exclusions = $(parent_node);
              $(included_item.exclusions).each(function(index, excluded_item) {
                excluded_child = $(child_node);
                excluded_child.attr("data-taxid", excluded_item.taxid);
                excluded_child.append($('<span><span class="before">But not:</span> ' + excluded_item.displayName + " </span>"));
                if (!excluded_item.programmatically) {
                  remove_link = $('<a class="right remove" title="Remove ' + excluded_item.name + '"></a>').on("click", $.proxy(that.removeSelectedItems, that, excluded_item.taxid));
                  excluded_child.append(remove_link);
                }
                exclusions.append(excluded_child);
                excluded_ids.push(excluded_item.taxid);
              });
              return exclusions;
            });
          }
          return child_content;
        });
      });
      $(container).html(content);
      document.querySelector("#tax_included").value = included_ids.join(",");
      document.querySelector("#tax_excluded").value = excluded_ids.join(",");
      this.number_selected = included_ids.length + excluded_ids.length;
      if (this.number_selected === 0) {
        $(container).hide();
      } else {
        $(container).show();
      }
    }
  });
  $.fn.taxIdLookup = function(options) {
    var til = new TaxIdLookup(this, options);
    if (til) {
      $(this).data("taxidlookup", til);
      til.listen();
      // Expose some methods to the global Hmmer object
            global.taxIdLookup = {
        includeItem: til.includeItem.bind(til),
        reset: til.removeSelectedItems.bind(til)
      };
    }
  };
  $.resetTaxonomyFilters = function() {
    if (!$("#taxfilter_content").hasClass("loaded")) return;
    var reset1 = $.proxy($(".taxidsearch").data("taxidlookup").reset, $(".taxidsearch").data("taxidlookup"));
    var reset2 = $.proxy($("#tax_filter").data("tax_tree").reset, $("#tax_filter").data("tax_tree"));
    reset1();
    reset2();
  };
  /****************************************************
  Setup
  *****************************************************/  var loadTaxTree = function() {
    if ($("#taxfilter_content").hasClass("loaded")) return;
    $("#tax_filter").taxonomyTree({
      source: function() {
        var data;
        return function(cb) {
          if (data) {
            cb(data);
            return;
          }
          $.ajax({
            url: site_url + "static/taxonomy/taxon.json?rel_" + "2.41.1",
            dataType: "json",
            success: cb
          });
        };
      }()
    });
    $("#taxfilter_content").addClass("loaded");
  };
  $(document).on("click", "#tax_tree_radio", loadTaxTree);
  $(document).ready(function() {
    // Something is not setting the class, so doing it here (dirty fix)
    setTimeout(function() {
      var el = document.querySelector("#taxfilter_content input:checked");
      if (el) {
        el.parentElement.parentElement.classList.add("selected");
      }
    }, 500);
    $(".taxidsearch").taxIdLookup({
      minLength: 3,
      items: 15,
      source: function(query, process) {
        return $.ajax({
          url: site_url + "autocomplete/taxonomyid",
          type: "get",
          data: {
            q: query,
            included: $("#tax_included").val(),
            excluded: $("#tax_excluded").val()
          },
          dataType: "json",
          success: function(results) {
            process(results);
          }
        });
      }
    });
    //enable the add all link
        $(".include-all-taxa").on("click", function() {
      //We need the call to look like it was initiated internally, so proxy it
      $.proxy($(".taxidsearch").data("taxidlookup").includeItem, $(".taxidsearch").data("taxidlookup"))({
        taxid: "1",
        lft: "0",
        rgt: "99999999",
        displayName: "All Organisms",
        name: "All Organisms",
        inclusion: true
      });
    });
    //stop the search field from trying to submit the form when enter is pressed
        $(".taxidsearch").keydown(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        return false;
      }
    });
    //disable tax filter for some db selections
        $('input[name="seqdb"]').on("click", function(e) {
      var target = e.target;
      if ($(target).hasClass("disable_tax_filter")) {
        $("#taxfilter_content").addClass("disabled");
      } else {
        $("#taxfilter_content").removeClass("disabled");
      }
    });
    $(".disable_tax_filter").each(function(index, node) {
      if ($(node).prop("checked")) {
        $("#taxfilter_content").addClass("disabled");
      }
    });
  });
  /****************************************************
  //reload tax filter from form data
  *****************************************************/  $("document").ready(function() {
    var reloadFunc = function(taxData) {
      if (!taxData) {
        $("#tax_search_radio").click();
        return;
      }
      //Expand the taxonomy filter section
            $("#taxfilter_content").addClass("reloading");
      $(".taxonomy legend span").click();
      //Get the data
            var json_data = $.parseJSON(taxData);
      var included_ids = json_data.tax_included;
      var excluded_ids = json_data.tax_excluded;
      var include = $.proxy($(".taxidsearch").data("taxidlookup").includeItem, $(".taxidsearch").data("taxidlookup"));
      var get_inclusion = $.proxy($(".taxidsearch").data("taxidlookup").getInclusionItem, $(".taxidsearch").data("taxidlookup"));
      var makeDisplayName = function(name, taxid) {
        return name + ' <span class="taxid">(taxid: ' + taxid + ")</span>";
      };
      var addItems = function(taxid, taxItemData, mode) {
        var incItem = $("<div>");
        if (taxid === "1") {
          incItem.attr("data-taxid", "1");
          incItem.attr("data-lft", "0");
          incItem.attr("data-rgt", "99999999");
          incItem.attr("data-display_name", "All Organisms");
          incItem.attr("data-name", "All Organisms");
        } else {
          incItem.attr("data-taxid", taxid);
          incItem.attr("data-lft", taxItemData.lft);
          incItem.attr("data-rgt", taxItemData.rgt);
          incItem.attr("data-display_name", makeDisplayName(taxItemData.name, taxid));
          incItem.attr("data-name", taxItemData.name);
        }
        if (mode === "exclusion") {
          incItem.attr("data-ancestor", get_inclusion(taxItemData.lft));
        }
        incItem.addClass(mode);
        include(incItem);
      };
      //Which widget?
            var filterType = $("#last_tab_clicked").val();
      if (!filterType) {
        filterType = "search";
      }
      if (filterType === "search") {
        $.each(included_ids, function(taxid, taxItemData) {
          addItems(taxid, taxItemData, "inclusion");
        });
        //add excluded items
                if (excluded_ids) {
          $.each(excluded_ids, function(taxid, taxItemData) {
            addItems(taxid, taxItemData, "exclusion");
          });
        }
        $("#tax_search_radio").prop("checked", "checked");
        $("#tax_search_radio").closest("li").addClass("selected");
        $("#tax_tree_radioOpt").closest(".group").hide();
      } else {
        loadTaxTree();
        $($("#tax_included").val().split(",")).each(function(index, taxid) {
          var cb_id = "#cb_" + taxid;
          $(cb_id).click();
        });
        $("#tax_tree_radio").prop("checked", "checked");
        $("#tax_tree_radio").closest("li").addClass("selected");
        $("#tax_search_radioOpt").closest(".group").hide();
      }
      $("#taxfilter_content").removeClass("reloading");
    };
    //check if we need to get the taxfilter_data
        if ((typeof $("#taxfilter_data").val() === "undefined" || !$("#taxfilter_data").val().length) && (typeof $("#tax_included").val() !== "undefined" && $("#tax_included").val().length || typeof $("#tax_excluded").val() !== "undefined" && $("#tax_excluded").val().length)) {
      var filterType = $("#last_tab_clicked").val();
      if (filterType === undefined || filterType == "") {
        filterType = "search";
      }
      $.ajax({
        url: site_url + "/search/taxfilter_data?nocache=",
        data: {
          taxFilterType: filterType,
          tax_included: $("#tax_included").val(),
          tax_excluded: $("#tax_excluded").val()
        },
        type: "POST",
        success: function(json) {
          reloadFunc(json);
        }
      });
    } else {
      reloadFunc($("#taxfilter_data").val());
    }
  });
})(jQuery, __HmmerGlobal);

/** @preserve
 * HMMER website functions.
*/
(function($, global) {
  var site_url = document.location.origin + "/";
  var pathname = document.location.pathname;
  var reg = /Tools\/hmmer/;
  var match = pathname.match(reg);
  if (match) {
    site_url = document.location.origin + "/Tools/hmmer/";
  }
  $.ajaxSetup({
    // set a default timeout of 10 seconds for all ajax methods.
    timeout: $("document").timeout
  });
  $("#error").ajaxError(function() {
    $(this).children().remove().end().addClass("warning").append("<p>There was an error dynamically loading content for this page. " + "Refreshing the page may clear this problem. If it continues to " + "persist, please " + '<a href="https://www.ebi.ac.uk/support/hmmer">contact us</a>.' + "</p>");
  });
  window.addEventListener("unload", function() {
    // try to make sure buttons aren't disabled if someone clicks back button.
    var submitButton = document.querySelector("form input[type=submit]");
    if (submitButton) submitButton.disable = false;
    [].slice.call(document.querySelectorAll(".loading")).forEach(function(el) {
      el.parentNode.removeChild(el);
    });
  });
  var getHelpContent = function(element) {
    var href = element.href;
    var content = $(element).parent().siblings(".help");
    if (href) {
      content = content.append("<br/>").append($("<a>more</a>").attr("href", href));
    }
    return content.html();
  };
  $("document").ready(function() {
    /*$('.nav_toggle').click(function() {
      $('#tabs').toggleClass('tab_hidden');
    });
    $('.subnav_toggle').click(function() {
      $('#subnav').toggleClass('tab_hidden');
    });
    $('.menu').nav_menu();
*/
    /**** changes if page embedded in an iframe ******************/
    if (window !== window.top) {
      try {
        ga("send", "event", "iframe", "loaded", window.parent.location || document.referrer);
      } catch (e) {}
      // hide header
            document.querySelector("header").style.display = "none";
      // hide 'search again' button, if it exists
            var searchAgainButton = document.querySelector("a.again");
      if (searchAgainButton) searchAgainButton.style.display = "none";
      // hide footer
            var footer = document.querySelector("body > footer");
      if (footer) footer.style.display = "none";
      // intercept all the clicks
            document.addEventListener("click", function(e) {
        // skip if not a link
        if (e.target.tagName !== "A") return;
        // skip if internal link
                if (e.target.href.indexOf(site_url) === 0) return;
        // change the target attribute on the fly
                e.target.target = "_parent";
      });
    }
    /**** Check version consistency ****/    var versionSpan = document.getElementById("hmmer-version");
    if (versionSpan.textContent.trim() !== "2.41.1") {
      console.warn("The Catalyst and the NPM versioning are not in sync");
      console.warn("Catalyst: " + versionSpan.textContent.trim() + ", NPM: " + "2.41.1");
    }
    // Switch to gathering threshold on home page
        var homeSearch = document.querySelector(".home .search-options");
    if (homeSearch) {
      var otherInputs = Array.prototype.slice.call(document.querySelectorAll("#incE, #incdomE, #E, #domE, #bit, #evalue"));
      var gatheringInput = document.querySelector("#cut_ga");
      var pfamRadioInput = homeSearch.querySelector("#db_pfam");
      homeSearch.addEventListener("change", function() {
        var pfamIsChecked = pfamRadioInput.checked;
        otherInputs.forEach(function(i) {
          i.disabled = pfamIsChecked;
        });
        gatheringInput.disabled = !pfamIsChecked;
      });
    }
    /********************* init form settings ********************/
    //Autocomplete
    /* will call a url like so :
    /autocomplete/accorid?q=asr&limit=21&timestamp=1364304164428
    where q is the query string and limit is the number of results to return. */    $("#acc, #hmm_acc, .all_acc").attr("autocomplete", "off");
    $("#acc").typeahead({
      minLength: 3,
      items: 21,
      source: function(query, process) {
        return $.ajax({
          url: site_url + "autocomplete/accorid",
          type: "get",
          data: {
            q: query,
            timestamp: Math.floor(+new Date() / 1e3)
          },
          dataType: "text",
          success: function(results) {
            return process(results.split("\n"));
          }
        });
      }
    });
    $("#hmm_acc").typeahead({
      minLength: 1,
      items: 21,
      source: function(query, process) {
        return $.ajax({
          url: site_url + "/autocomplete/hmmaccorid",
          type: "get",
          data: {
            q: query,
            timestamp: Math.floor(+new Date() / 1e3)
          },
          dataType: "text",
          success: function(results) {
            return process(results.split("\n"));
          }
        });
      }
    });
    $(".all_acc").typeahead({
      minLength: 1,
      items: 21,
      source: function(query, process) {
        return $.ajax({
          url: site_url + "/autocomplete/allaccorid",
          type: "get",
          data: {
            q: query,
            timestamp: Math.floor(+new Date() / 1e3)
          },
          dataType: "text",
          success: function(results) {
            return process(results.split("\n"));
          }
        });
      }
    });
    $("#pfamEvalue").attr("disabled", true);
    // insert the advanced search toggle
        if ($(".advField").length) {
      var button = $('<button id="advOpts" class="button">Advanced</button>').click(function(e) {
        $(".advField").show();
        $(this).hide();
        e.preventDefault();
      });
      $(".advField").after($('<div class="centered">').append(button));
    }
    // enable forms on page reload.
        $("form input[type=submit]").removeAttr("disabled");
    $(".loading").remove();
    $("form input[type=reset]").click(function() {
      $("form input[type=submit]").removeAttr("disabled").removeClass("disabled-button");
      $(".loading").remove();
    });
    $("form").submit(function(e) {
      if (e.target.classList.contains("search")) return;
      if ($(this).attr("id") !== "customise") {
        $("input[type=submit]", this).attr("disabled", "disabled").addClass("disabled-button").after('<span class="loading">loading, please wait...</span>');
      }
      // Need to modify a bit the form data before sending it to the server
      // if this is for an other iteration
            if (e.target.id && e.target.id === "next_iteration" && !e.target.classList.contains("default")) {
        // Take over the automatic submit event, a new one will be sent later
        e.preventDefault();
        // Retrieve data from the session storage
                var key = "HmmerWeb_Jackhmmer_prepare_next_iteration";
        var data = JSON.parse(sessionStorage.getItem(key)).body;
        // Send the modified data
                $.post(e.target.action, [ {
          name: "uuid",
          value: this.querySelector("[name=uuid]").value
        }, {
          name: "iteration",
          value: this.querySelector("[name=iteration]").value
        }, {
          name: "removeAll",
          value: data.removeAll
        }, {
          name: "add",
          value: data.add
        }, {
          name: "remove",
          value: data.remove
        } ]).always(function() {
          sessionStorage.removeItem(key);
          window.location.href = window.location.href.replace(/\.\d+\/score/, "/score");
        });
      }
    });
    /******************* modify row count warning ********************/    var advrowslink = $("<a>Advanced</a>").click(function() {
      $(".adv").click();
    });
    var restoredefaults = $("<a>restoring the default row count</a>").click(function() {
      $("#r100").click();
      $("#info").empty().removeClass("warning");
    });
    $("#row_warn_replace").empty().append("We suggest clicking on the '").append(advrowslink).append("' link and reducing the number of rows to less than 1000 or ").append(restoredefaults).append(".");
    /***************** setup tabs***********************/
    // find all the sections that need to be tabbed
        $(".tabbed").each(function() {
      var tabbed = $(this);
      // put a new navigation list before the first child fieldset
            var nav_list = $("<ul>").addClass("tabbed_nav clearfix");
      tabbed.find("fieldset:first").before(nav_list);
      // for each legend add an item to the tabbed_nav list
            tabbed.find("fieldset legend").each(function() {
        nav_list.append($("<li>").append($(this).html()));
      });
      // remove the redundant legends and add a group class for formating
            tabbed.find("fieldset").addClass("group").find("legend").remove();
      //add confirmation
            if (tabbed.parent().hasClass("taxonomy")) {
        $(tabbed).find("li").each(function() {
          var that = $(this);
          var message = $("<p/>", {
            text: "This will clear your current selections, are you sure?"
          });
          var ok = $("<input>", {
            type: "button",
            value: "Ok",
            class: "confirm_ok",
            click: function() {
              //reset taxonomy filter
              $.resetTaxonomyFilters();
              //change the tab..
                            var e = {
                target: that.find("input")[0],
                isPropagationStopped: function() {
                  return false;
                }
              };
              tab_click(e);
              $(".qtip").qtip("hide");
            }
          });
          var cancel = $("<input>", {
            type: "button",
            value: "Cancel",
            class: "confirm_cancel",
            click: function() {
              //do nothing (well... hide the qtip)
              $(".qtip").qtip("hide");
            }
          });
          var content = $("<div>").append(message).append(ok).append(cancel);
          $(this).qtip({
            content: {
              text: content,
              title: "Please confirm"
            },
            position: {
              my: "bottom center",
              at: "top center"
            },
            style: {
              classes: "ui-tooltip-hmmer ui-tooltip-rounded confirm-dialog"
            },
            show: {
              event: "",
              //Stop the qtip from showing on normal events
              modal: {
                on: true
              }
            },
            hide: false
          });
        });
      }
      // build the toggle events.
            var tab_click = function(e) {
        if (e.isPropagationStopped()) {
          return false;
        }
        var target = $(e.target);
        target.prop("checked", true);
        // trigger the select so we show the correct tab
                target.closest(".tabbed_nav").find("li").removeClass("selected");
        target.closest("li").addClass("selected");
        // disable the form elements in all tabs
                tabbed.find("fieldset input").attr("disabled", "disabled");
        // enable form elements in this tab
                var selected = "#" + target.attr("id") + "Opt";
        $(selected).find("input").removeAttr("disabled");
        // hide all the sections
                tabbed.find("fieldset").hide();
        // show selected
                $(selected).parent().show();
        //track last clicked tab
                if (tabbed.closest(".tabbed").parent().hasClass("taxonomy")) {
          if ($(e.target).val() !== "evalue") {
            $("#last_tab_clicked").val($(e.target).val());
          }
        }
      };
      var sections = nav_list.find("input");
      sections.each(function() {
        //carve out for taxonomy confirmation
        if ($(this).closest(".tabbed").parent().hasClass("taxonomy")) {
          $(this).click(function(e) {
            if ($("#tax_included").val().length && !$("#taxfilter_content").hasClass("reloading")) {
              $(this).closest("li").qtip("show", e);
              $(".confirm_ok:visible").focus();
              return false;
            } else {
              tab_click(e);
            }
          });
        } else {
          $(this).click(tab_click);
        }
      });
      // click on the radio button that was selected.
            if (!$(this).parent().hasClass("taxonomy") || !$("#taxfilter_data").length) {
        nav_list.find("input[type=radio]:checked").click();
      }
    });
    /******************** init click functions ********************/    $("#reset").click(function() {
      $("textarea").val("").text("");
      $("#ga").click();
      if (hasLoadedTheTextarea()) {
        document.getElementById("textarea_seq").quill.setText("");
      }
    });
    $("#example").click(function(e) {
      loadExample(e, ">2abl_A mol:protein length:163  ABL TYROSINE KINASE\n" + "MGPSENDPNLFVALYDFVASGDNTLSITKGEKLRVLGYNHNGEWCEAQTKNGQGWVPSNYITPVNS" + "LEKHSWYHGPVSRNAAEYLLSSGINGSFLVRESESSPGQRSISLRYEGRVYHYRINTASDGKLYVS" + "SESRFNTLAELVHHHSTVADGLITTLHYPAP");
    });
    $("#aliexample").click(function(e) {
      loadExample(e, $("#example_ali").text());
    });
    $("#hmmexample").click(function(e) {
      loadExample(e, $("#example_hmm").text());
    });
    $(".seq_options a").click(function() {
      $(".seq_options a").removeClass("selected");
      $(this).addClass("selected");
      $(".seqInput").hide();
      $("#seq" + $(this).attr("alt")).show();
    });
    $(".collapsible legend span").click(function() {
      if ($(this).closest("fieldset").hasClass("collapsed")) {
        $(this).closest("fieldset").removeClass("collapsed").addClass("expanded");
        if (!$(this).closest("div").hasClass("disabled")) {
          $(this).closest("fieldset").children("div").show("fast");
        }
      } else {
        $(this).closest("fieldset").removeClass("expanded").addClass("collapsed").children("div").hide("fast");
      }
    });
    $("#gaButton").click(function() {
      $("#pfamEvalue").attr("disabled", true);
    });
    $("#eButton").click(function() {
      $("#pfamEvalue").attr("disabled", false);
    });
    /************************** setup tooltips ******************/    $.fn.tooltip = function(position) {
      $(this).each(function() {
        $(this).click(function(e) {
          e.preventDefault();
        });
        var content = getHelpContent(this);
        var isAbove = position === "above";
        $(this).qtip({
          content: {
            text: content
          },
          style: {
            tip: {
              corner: isAbove ? "bottom center" : "left center"
            },
            classes: "ui-tooltip-hmmer ui-tooltip-rounded"
          },
          show: {
            solo: true,
            event: "mouseover"
          },
          hide: {
            fixed: true,
            delay: 1e3,
            event: "mouseout"
          },
          position: {
            at: isAbove ? "top center" : "center right",
            my: isAbove ? "bottom center" : "center left",
            target: $(this)
          }
        });
      });
      return this;
    };
    $(".collapsible legend a, .custom h5 a, .custom .title a, " + "h5.left a, .tooltip, .tooltip_item").tooltip();
    /*********** phmmer/hmmsearch alignment toggling code ********/    $(".alilink").click(function(e) {
      e.preventDefault();
    });
    var ali_loading = [];
    $(document).on("click", ".resultTable .aliswitch", function(e) {
      var td = $(this);
      var link = td.find("a");
      var position = td.parent().index();
      var colspan = 0;
      if ($(this).closest("table").attr("id") === "list") {
        colspan = $(this).closest("table").find(".titleRow th:visible").length;
      } else {
        colspan = $(this).closest("table").find(".titleRow th").length;
      }
      $("td.alignment").attr("colspan", colspan);
      if (td.closest("tr").next(".ali").length) {
        var closing = link.hasClass("rotate90");
        link.toggleClass("rotate90");
        var ali = td.closest("tr").next(".ali");
        if (closing) {
          var aliMetas = ali[0].querySelectorAll(".alimeta");
          if (ali[0].animate && aliMetas.length) {
            [].slice.call(ali[0].querySelectorAll(".alimeta")).map(function(el) {
              return el.animate([ {
                height: el.getBoundingClientRect().height + "px"
              }, {
                height: "0"
              } ], {
                duration: 250,
                easing: "ease-in-out"
              });
            })[0].onfinish = function() {
              ali.toggle();
            };
          } else {
            ali.toggle();
          }
        } else {
          ali.toggle();
          if (ali[0].animate) {
            [].slice.call(ali[0].querySelectorAll(".alimeta")).forEach(function(el) {
              el.animate([ {
                height: "0"
              }, {
                height: el.getBoundingClientRect().height + "px"
              } ], {
                duration: 250,
                easing: "ease-in-out"
              });
            });
          }
        }
      } else if (!ali_loading[position]) {
        ali_loading[position] = true;
        $.get(link.attr("href"), function(data) {
          var alignment = $("<tr>").addClass("ali").append($('<td colspan="' + colspan + '">').append(data));
          link.closest("tr").after(alignment);
          link.toggleClass("rotate90");
          var el = alignment.find(".alimeta")[0];
          if (el && el.animate) {
            var height = el.getBoundingClientRect().height;
            el.animate([ {
              height: "0"
            }, {
              height: height + "px"
            } ], {
              duration: 250,
              easing: "ease-in-out"
            });
          }
          // add tooltips
                    var contents = $("#alignmentKey").html();
          alignment.find(".alignment").qtip({
            content: contents,
            style: {
              classes: "ui-tooltip-hmmer-align ui-tooltip-rounded"
            },
            show: {
              solo: true,
              event: "mouseover"
            },
            hide: {
              event: "mouseout",
              delay: 500
            },
            position: {
              at: "bottom center",
              my: "top center"
            }
          });
          ali_loading[position] = false;
        });
      }
      e.preventDefault();
    });
    $("#ali_show_all").click(function(e) {
      var button = $(this);
      button.attr("disabled", "disabled");
      $(".ali").show();
      $(".alitoggle").each(function() {
        $(this).addClass("rotate90");
      });
      button.replaceWith('<a href="" class="small" id="ali_hide_all">(hide&nbsp;all)</a>');
      e.preventDefault();
    });
    $("#ali_hide_all").click(function(e) {
      var button = $(this);
      button.attr("disabled", "disabled");
      $(".ali").hide();
      $(".aliswitch a").removeClass("rotate90");
      button.replaceWith('<a href="" class="small" id="ali_show_all">(show&nbsp;all)</a>');
      e.preventDefault();
    });
    /**************** identical sequences popup *****************/    $.fn.seqpopup = function() {
      $(this).each(function() {
        $(this).qtip({
          content: {
            text: "loading...",
            ajax: {
              url: $(this).attr("href")
            },
            title: {
              text: "Identical Sequences",
              button: "Close"
            }
          },
          position: {
            my: "center",
            at: "center",
            target: $(this).closest("tr"),
            effect: false
          },
          show: {
            event: "click",
            solo: true
          },
          style: {
            classes: "ui-tooltip-hmmerseq ui-tooltip-rounded ui-tooltip-shadow"
          },
          hide: "unfocus"
        }).click(function(e) {
          e.preventDefault();
        });
      });
    };
    $("#list .seqlink").seqpopup();
    /**************** search again popup ****************************/    $.fn.searchAgainPopUp = function() {
      $(this).each(function() {
        var url = $(this).attr("href");
        var uuid = $(this).attr("data-jobid");
        var link = site_url + "/search/hmmsearch?uuid=" + uuid;
        var content = $("<p>Perform a new search</p>").append($("<ul>").append($("<li>").append($("<a>with new input</a>").attr("href", url))).append($("<li>").append($("<a>with these results</a>").attr("href", link))));
        $(this).qtip({
          content: content,
          style: {
            tip: {
              corner: "top right",
              border: 1
            },
            classes: "ui-tooltip-rounded ui-tooltip-hmmerdist"
          },
          show: {
            event: "mouseover"
          },
          hide: "unfocus",
          position: {
            at: "bottom right",
            my: "top right"
          }
        }).click(function(e) {
          e.preventDefault();
        });
      });
    };
    $(".reuse").searchAgainPopUp();
    /**************** identical sequences next link *****************/    $(document).on("click", "#identical_nav", function(e) {
      var link = $(this);
      $.get(link.attr("href"), function(data) {
        link.closest("div").replaceWith(data);
      });
      e.preventDefault();
    });
    /**************** setup meta info toggle *******************/    $.fn.meta_toggle = function() {
      $(this).find(".provenance").hide().end().find(" > a").toggler(function() {
        $(this).next().slideDown();
      }, function() {
        $(this).next().slideUp();
      });
    };
    /******************* add customise toggle *********************/    $.fn.addCustomToggle = function() {
      this.each(function() {
        var link = $('<a href="#" class="button small">Customise</a>').click(function(e) {
          $(".custom").toggle();
          e.preventDefault();
        });
        $(this).append(link);
      });
      return this;
    };
    $("#list caption span.right").addCustomToggle();
    /**************** setup simple table toggle *******************/    $.fn.simpleTable = function() {
      var table = $(this);
      if (!this.length) {
        return;
      }
      var adv = $('<a class="button small right">Advanced</a>').click(function() {
        if ($(this).text() === "Advanced") {
          $(this).text("Standard");
          $(this).parents("table").find("td.advanced, th.advanced").show();
        } else {
          $(this).text("Advanced");
          $(this).parents("table").find("td.advanced, th.advanced").hide();
        }
      });
      adv.qtip({
        content: "Click to toggle more information about the Alignment, " + "Model, Bias and Bit Score.",
        style: {
          tip: {
            corner: "bottom right",
            border: 1
          },
          classes: "ui-tooltip-hmmer ui-tooltip-rounded"
        },
        show: {
          event: "mouseover"
        },
        hide: {
          event: "mouseout"
        },
        position: {
          at: "top center",
          my: "bottom right"
        }
      });
      table.find("> caption").prepend(adv);
      table.find("td.advanced, th.advanced").hide();
    };
    /******************* toggle hmmscan alignments *********************/    $.fn.alignmentToggle = function(wide) {
      if (!this.length) return;
      var table = $(this);
      var rowspan = 2;
      var colspan = 16;
      if (wide) {
        rowspan = 3;
        colspan = 18;
      }
      table.find("tr:eq(0)").prepend('<th rowspan="' + rowspan + '"></th>');
      table.find("> tbody > tr:even").prepend('<td class="centered alishow"><a class="alitoggle" href="">&gt;</a>' + "</td>");
      table.find("> tbody > tr:odd > td").attr("colspan", colspan);
      table.find("tfoot td").attr("colspan", colspan);
      table.find("td.alishow a").click(function(e) {
        $(this).parent().parent().next().toggle();
        $(this).toggleClass("rotate90");
        e.preventDefault();
      });
      // add tooltip
            var contents = $("#scanAlignmentKey").html();
      table.find("tr.alignment").qtip({
        content: contents,
        style: {
          classes: "ui-tooltip-hmmer-align ui-tooltip-rounded",
          tip: {
            corner: "top center",
            border: 1
          }
        },
        show: {
          solo: true,
          event: "mouseenter"
        },
        hide: {
          event: "mouseleave",
          delay: 500
        },
        position: {
          at: "bottom center",
          my: "top center"
        }
      });
      return table;
    };
    /********************* toggle hmmscan table ********************/    $.fn.addHmmscanToggle = function() {
      var table = $(this);
      table.hide();
      var block = $('<div class="centered">');
      var link = $("<a>Show hit details</a>").attr("href", "").toggler(function(e) {
        table.show();
        $(this).text("Hide details");
        e.preventDefault();
      }, function(e) {
        table.hide();
        $(this).text("Show hit details");
        e.preventDefault();
      });
      // $('.domwrapper').after(block.append(link));
            var link_2 = $("<div><a>Load coverage and identity heatmap</a></div>").attr("href", "").attr("id", "coverage_heatmap_loading_text").one("click", function(e) {
        $(this).text("Loading coverage and identity heatmap...");
        $.loadCoverageAndIdentityPlot(uuid);
        e.preventDefault();
      }).click(function(e) {
        e.preventDefault();
      });
      $(".domwrapper").after(block.append(link_2).append(link));
    };
    if ($("#aliupload").length) {
      $("#iterativeSearchForm #jack_example").click(function(e) {
        if ($("#aliupload:checked").val()) {
          var exHmm = $("#example_ali").text();
          $("#seq").val(exHmm).text(exHmm).change();
        } else {
          var exSeq = $("#example_seq").text();
          $("#seq").val(exSeq).text(exSeq).change();
        }
        e.preventDefault();
      });
      if ($("#aliupload:checked").val()) {
        $("#gapPen").hide().find("input,select").attr("disabled", true);
        // Attach this here so that we can figure out what the default was
        // if someone hits the reset button.
            } else {
        $("#gapPen").show().find("input,select").removeAttr("disabled");
      }
      $("#aliupload").on("click", function() {
        $("#seq").removeClass("sequence").addClass("hmmseq");
        $("#gapPen").hide().find("input,select").attr("disabled", true);
      });
      $("#sequpload").on("click", function() {
        $("#seq").removeClass("hmmseq").addClass("sequence");
        $("#gapPen").show().find("input,select").removeAttr("disabled");
      });
      /* Since the reset button wont reset the hidden elements,
       * we have to take care of it. This uses the previously stored default
       * to reset the form. We have to use the previously stored default,
       * because the click event fires before the form data is reset and
       * we have no way of knowing what the default was otherwise. */      $("#reset").click(function() {
        $("#gapPen").hide().find("input,select").attr("disabled", true);
      });
    }
    $(".archshow").click(function(e) {
      var link = $(this);
      e.preventDefault();
      // already loading the content, so just return.
            if (link.closest("li").children(".loading").length) {
        return;
      }
      if (!link.closest("li").children("table").length) {
        var loader = $("<div>").addClass("centered loading").append($("<p>loading...</p>"), $("<img/>").attr("src", "/Tools/hmmer/static/images/loading.gif").attr("alt", "loading"));
        link.closest("li").append(loader);
        $.get(link.attr("href"), function(data) {
          loader.replaceWith(data);
          // render the domains
                    link.closest("li").children("table").find(".domGraphics").each(function() {
            $(this).text("");
            var id = "#" + $(this).attr("id");
            var seq_id = id.replace("#dom_", "seq_");
            var pg = new global.PfamGraphic();
            pg.setParent(id);
            pg.setSequence(window[seq_id]);
            pg.render();
            var new_width = $(this).parent().width();
            pg.resize(new_width);
          });
          link.children("span.show").text("Hide All");
        });
      } else {
        link.closest("li").children("table").toggle();
        link.closest("li").children(".more_arch_hits").toggle();
        link.children("span.show").text(link.children("span.show").text() === "Show All" ? "Hide All" : "Show All");
        link.removeClass("archshow").addClass("archtoggle").click(function(e) {
          $(this).closest("li").children("table").toggle();
          $(this).closest("li").children(".more_arch_hits").toggle();
          var ltext = $(this).children("span.show");
          ltext.text(ltext.text() === "Show All" ? "Hide All" : "Show All");
          e.preventDefault();
        });
      }
    });
    $(document).on("click", ".more_arch_hits", function(e) {
      var link = $(this);
      e.preventDefault();
      link.hide();
      var loader = $("<div>").addClass("centered loading").append($("<p>loading...</p>"), $("<img/>").attr("src", "/Tools/hmmer/static/images/loading.gif").attr("alt", "loading"));
      link.closest("li").append(loader);
      $.get(link.attr("href"), function(data) {
        loader.replaceWith(data);
        var domObj = link.closest("li").children("table").find(".domGraphics");
        link.remove();
        domObj.each(function() {
          if (!$(this).children("svg").length) {
            $(this).empty();
            var id = "#" + $(this).attr("id");
            var seq_id = id.replace("#dom_", "seq_");
            var pg = new global.PfamGraphic();
            pg.setParent(id);
            pg.setSequence(window[seq_id]);
            pg.render();
          }
        });
      });
    });
    /**
    * init fixed position header
    * this keeps the primary navigation at the top of the page when
    * scrolling to the bottom.
    **/
    /*if (
      document.documentElement.classList &&
      !document.documentElement.classList.contains('older')
    ) {
      var win = $(window);
      var isFixed = false;
      var navTop = 111;
      var cookieBanner;
      var nav = document.querySelector('#local-masthead > nav');
      win.on('scroll', function() {
        var scrollTop = win.scrollTop();
        //check if the EBI cookie banner is displayed
        if (!cookieBanner) {
          cookieBanner = document.getElementById('cookie-banner');
        }
        navTop = (cookieBanner && cookieBanner.style.top === '0px') ? 160 : 111;

        if (scrollTop >= navTop && !isFixed) {
          isFixed = true;
          nav.classList.add('fixed');
        } else if (scrollTop <= navTop && isFixed) {
          isFixed = false;
          nav.classList.remove('fixed');
        }
      });
    }*/
    // init close me link for results customise message
        $(document).on("click", ".notify a", function(e) {
      e.preventDefault();
      $(this).parent().hide();
      //set custom_alert value in session, so we remember to leave this hidden.
            $.post(site_url + "/session/custom_hide", {
        off: true
      }, function() {}, "json");
    });
    /* Jackhmmer */
    // add additional iteration button to jackhmmer results
        var unselectAllContainer = document.getElementById("unselect_all");
    var iterbutton = $(".iterbutton").clone();
    if (iterbutton.length) {
      iterbutton.find("input").click(function() {
        $("#next_iteration").submit();
        $(this).attr("disabled", "disabled").addClass("disabled-button").after('<span class="loading">loading, please wait...</span>');
      });
      $("#jackhmmer_nav .actions").after(iterbutton);
      if (unselectAllContainer) {
        // unselect_all (UA) logic
        (function(container, radios, tbody) {
          if (!tbody) return;
          // Set variables
                    var key = "HmmerWeb_Jackhmmer_prepare_next_iteration";
          var job = location.href.match(/results\/([^\/?]*)/i)[1];
          var checkboxes = [].slice.call(tbody.querySelectorAll("input[type=checkbox]"));
          // Helper functions
                    var objectKeys = function(obj) {
            var keys = [];
            for (var key in obj) {
              if (obj.hasOwnProperty(key)) keys.push(key);
            }
            return keys;
          };
          var updateDOM = function(container) {
            var displayingInfo = false;
            var info = container.querySelector(".info");
            return function(data) {
              // 'changes' set to true if any of the keys in 'add' or 'remove'
              // is set to true (meaning the default selection has been altered)
              var changes = [ "add", "remove" ].reduce(function(prev, type) {
                return prev || objectKeys(data[type]).find(function(key) {
                  return data[type][key];
                });
              }, false);
              if (displayingInfo !== changes) {
                displayingInfo = changes;
                info.style.opacity = displayingInfo ? 1 : 0;
              }
            };
          }(container);
          var add = function(value, isAbove) {
            if (data.body.removeAll || !isAbove) {
              // If in removeAll mode, or below the threshold, add
              data.body.add[value] = true;
            }
            if (data.body.remove[value]) data.body.remove[value] = false;
          };
          var remove = function(value, isAbove) {
            if (!data.body.removeAll && isAbove) {
              // If not in removeAll mode, and above the threshold, remove
              data.body.remove[value] = true;
            }
            if (data.body.add[value]) data.body.add[value] = false;
          };
          var tick = function(node) {
            node.checked = true;
          };
          var untick = function(node) {
            node.checked = false;
          };
          var above = function(node) {
            return node.classList.contains("above");
          };
          var below = function(node) {
            return !above(node);
          };
          var strToObj = function(str) {
            return str.split(/\s/).filter(function(key) {
              return key;
            }).reduce(function(accumulated, current) {
              accumulated[current] = true;
              return accumulated;
            }, {});
          };
          var objToStr = function(obj) {
            return objectKeys(obj).filter(function(key) {
              return obj[key];
            }).reduce(function(accumulated, current) {
              return accumulated + " " + current;
            }, "").trim();
          };
          var setDataInSessionStorage = function() {
            var stringify = function(data) {
              return JSON.stringify({
                job: data.job,
                body: {
                  removeAll: data.body.removeAll,
                  add: objToStr(data.body.add),
                  remove: objToStr(data.body.remove)
                }
              });
            };
            if (window.requestIdleCallback) {
              return function(data) {
                window.requestIdleCallback(function() {
                  sessionStorage.setItem(key, stringify(data));
                  updateDOM(data.body);
                }, {
                  timeout: 1e3
                });
              };
            } else if (window.requestAnimationFrame) {
              return function(data) {
                window.requestAnimationFrame(function() {
                  sessionStorage.setItem(key, stringify(data));
                  updateDOM(data.body);
                });
              };
            } else {
              return function(data) {
                window.setTimeout(function() {
                  sessionStorage.setItem(key, stringify(data));
                  updateDOM(data.body);
                }, 1);
              };
            }
          }();
          var getDataFromSessionStorage = function() {
            var data = JSON.parse(sessionStorage.getItem(key));
            if (!data || data.job !== job) {
              // The current job doesn't match the one in the 'data' object
              // so we reset it to the current one
              data = {
                job: job,
                body: {
                  removeAll: false,
                  add: {},
                  remove: {}
                }
              };
              setDataInSessionStorage(data);
            } else {
              data.body.add = strToObj(data.body.add);
              data.body.remove = strToObj(data.body.remove);
            }
            return data;
          };
          // Retrieve partial data for next iteration from sessionStorage
                    var data = getDataFromSessionStorage();
          // Initialise checkboxes according to 'data' removeAll mode
                    radios.querySelector("input[value=" + (data.body.removeAll ? "none" : "above") + "]").checked = true;
          if (data.body.removeAll) {
            checkboxes.forEach(function(checkbox) {
              if (data.body.add[checkbox.value]) {
                tick(checkbox);
              } else {
                untick(checkbox);
              }
            });
          } else {
            checkboxes.forEach(function(checkbox) {
              if (above(checkbox) && data.body.remove[checkbox.value]) {
                untick(checkbox);
              } else if (!above(checkbox) && data.body.add[checkbox.value]) {
                tick(checkbox);
              }
            });
          }
          updateDOM(data.body);
          // EventListeners
                    radios.addEventListener("change", function(e) {
            var removeAll = e.target.value === "none";
            data.body = {
              removeAll: removeAll,
              add: {},
              remove: {}
            };
            if (removeAll) {
              // Untick all the sequences
              checkboxes.forEach(untick);
            } else {
              checkboxes.filter(above).forEach(tick);
              checkboxes.filter(below).forEach(untick);
            }
            setDataInSessionStorage(data);
          });
          tbody.addEventListener("change", function(e) {
            var isAbove = e.target.classList.contains("above");
            if (e.target.checked) {
              add(e.target.value, isAbove);
            } else {
              remove(e.target.value, isAbove);
            }
            setDataInSessionStorage(data);
          });
        })(unselectAllContainer, unselectAllContainer.querySelector("form"), document.querySelector(".resultTable > tbody"));
      }
    } else {
      if (unselectAllContainer) {
        unselectAllContainer.style.display = "none";
      }
    }
    /******************* jump to link fix ***************************/
    // This fixes things that were below the floating header after
    // a jump.
    // grab the id out of the link
        $(".jumplink").click(function(e) {
      var page = $(this).attr("href").match(/page=(\d+)/);
      // if on the same page
            if (parseInt(global.dist_data.page, 10) === parseInt(page[1], 10)) {
        e.preventDefault();
        // scroll the page.
                $(window)[0].scrollTo(0, $("#first_new").offset().top - 24);
        $("#first_new").css("backgroundColor", "#ffe87c").animate({
          backgroundColor: "#fff"
        }, 3e3, function() {
          $(this).css("backgroundColor", "");
        });
      } else {
        e.preventDefault();
        //strip off the # tag and fire off the location change
                window.location = $(this).attr("href").replace(/#first_new/, ";jumpto=first_new");
      }
    });
    // show hmm logos if they are requested
        $(".hmmlogo").each(function() {
      var uuid = $(this).attr("data-uuid");
      var url = site_url + "/results/hmmlogo/" + uuid + ".png";
      var img = $("<img>").attr("alt", "HMM Logo").attr("src", url);
      $(this).append(img);
    });
    if (global.logo_data) {
      $("#logo_graphic").hmm_logo({
        column_width: 34,
        data: global.logo_data,
        alphabet: "aa",
        scaled_max: true
      });
    }
    // Disable multibutton navigation after clicking to prevent multiple
    // requests for the same content.
        $(".oneclick a").click(function() {
      $(this).text("loading...").off("click").click(function(e) {
        e.preventDefault();
      });
    });
    $(".jump").jumper();
  });
  /*****************navigation menu pop up********************/
  /* SP: don't think we need to show popup with new EBI template

  $.fn.nav_menu = function() {
    $(this).each(function() {
      $(this).click(function(e) {
        e.preventDefault();
      });
      var content = $('#menu-popup').html();

      var tooltips = $(this).qtip({
        content: content,
        style: {
          tip: {
            corner: false,
          },
          classes: 'ui-tooltip-hmmernav',
        },
        show: {
          event: 'mouseenter',
          target: $('.menu')
        },
        hide: {
          event: 'unfocus'
        },
        position: {
          adjust: {
            y: -30
          },
          at: 'bottom right',
          my: 'top right',
          target: $('.menu')
        }
      });
      var api = tooltips.qtip('api');
      $(document).on('mouseleave', '.menu-list', function(e) {
        e.preventDefault();
        api.hide();
      });
      $(document).on('mouseenter', '.current_tab', function() {
        api.show();
      });
    });
  };
*/
  /*********jump on page without header overlap*****************/  $.fn.jumper = function() {
    if (!$(this).length) return;
    var target = $($(this).attr("href"));
    if (target.length) {
      var top = target.position().top;
      $(this).click(function(e) {
        e.preventDefault();
        window.scrollTo(0, top);
      });
    }
  };
  /*********************sortable tables***********************/  $.fn.sortable = function() {
    var tableSel = $(this);
    // attach onclick events to thead
        tableSel.find("thead .sortable").on("click", function() {
      var table = tableSel[0];
      // removed sorted from all columns
            var previous = table.querySelector("thead .sorted");
      if (previous) previous.classList.remove("sorted");
      // $(this).closest('thead').find('.sorted').removeClass('sorted');
      // mark this as sorted for styling
            this.classList.add("sorted");
      // $(this).addClass('sorted');
      // need to figure out which column we are sorting on
            var columnNumber = this.dataset.column;
      // var columnNumber = $(this).attr('data-column');
            var body = table.querySelector("tbody");
      // build array to manipulate with the sort
      // var rows = [];
      // var row_total = table.find('tbody tr').not('.alignment').size();
      //
      // for (var row = 0; row < row_total; row++) {
      //   rows[row] = [];
      // }
            var sortFunction;
      if (this.classList.contains("numeric") || this.classList.contains("evalue")) {
        sortFunction = function(a, b) {
          return parseFloat(a.value) - parseFloat(b.value);
        };
      }
      [].slice.call(table.querySelectorAll("tbody tr:not(.alignment):not(.ali)")).map(function(row) {
        var ali = row.nextElementSibling;
        if (!ali || !ali.classList.contains("alignment") && !ali.classList.contains("ali")) {
          ali = null;
        }
        return {
          value: row.children[columnNumber].textContent,
          row: row,
          alignment: ali
        };
      }).sort(sortFunction).forEach(function(row) {
        body.appendChild(row.row);
        if (row.alignment) {
          body.appendChild(row.alignment);
        }
      });
      // table.find('tbody tr').not('.alignment').each(function(i) {
      //   rows[i][0] = $(this).find('td').eq(columnNumber).text();
      //   rows[i][1] = this;
      // });
      // now sort the rows array
      // if ($(this).hasClass('numeric')) {
      //   rows.sort(function(a, b) {
      //     return a[0] - b[0];
      //   });
      // } else if ($(this).hasClass('evalue')) {
      //   rows.sort(function(a, b) {
      //     return parseFloat(a[0]) - parseFloat(b[0]);
      //   });
      // } else {
      //   rows.sort();
      // }
      //
      // //now remove each one from the dom and put it at the end of the table.
      // for (var row2 = 0; row2 < rows.length; row2++) {
      //   var meta = rows[row2][1];
      //   var alignment = $(rows[row2][1]).next('.alignment');
      //
      //   $(meta).detach();
      //   $(alignment).detach();
      //
      //   table.find('tbody').append(meta).append(alignment);
      // }
        });
  };
  /********************distribution graphic tooltip***********/  $.fn.help = function() {
    if (!this.length) return;
    var content = getHelpContent(this[0]);
    $(this).click(function(e) {
      e.preventDefault();
    }).qtip({
      content: content,
      style: {
        tip: {
          border: 1
        },
        classes: "ui-tooltip-hmmerdist ui-tooltip-rounded"
      },
      show: {
        solo: true,
        event: "mouseover"
      },
      hide: {
        fixed: true,
        delay: 1e3,
        event: "mouseout"
      },
      position: {
        viewport: $(window),
        at: "top center",
        my: "bottom right"
      }
    });
  };
  $(document).on("load_annotations", "#domGraph", function() {
    var ncoils = null;
    $(this).parent().after($("#annotation_ind").html());
    /* coils annotation */    if (!global.annotation.coilsUUID) {
      $.post(site_url + "annotation/coils", {
        uuid: uuid
      }, null, "json").done(function(data) {
        ncoils = $.loadNcoilsAnnotation(data.uuid);
      });
    } else {
      ncoils = $.loadNcoilsAnnotation(global.annotation.coilsUUID);
    }
    var phobius = null;
    /* phobius annotation */    if (!global.annotation.phobiusUUID) {
      $.post(site_url + "annotation/phobius", {
        uuid: uuid
      }, null, "json").done(function(data) {
        phobius = $.loadPhobiusAnnotation(data.uuid);
      });
    } else {
      phobius = $.loadPhobiusAnnotation(global.annotation.phobiusUUID);
    }
    var disorder = null;
    /* disorder annotation */    if (!global.annotation.disorderUUID) {
      $.post(site_url + "annotation/disorder", {
        uuid: uuid
      }, null, "json").done(function(data) {
        disorder = $.loadDisorderAnnotation(data.uuid);
      });
    } else {
      disorder = $.loadDisorderAnnotation(global.annotation.disorderUUID);
    }
    /* superfamily annotation */    if (global.annotation.superfamilyUUID) {
      $.loadHmmscanAnnotation(global.annotation.superfamilyUUID, "superfamily");
    }
    /* treefam annotation */    if (global.annotation.treefamUUID) {
      $.loadHmmscanAnnotation(global.annotation.treefamUUID, "treefam");
    }
    /* tigrfam annotation */    if (global.annotation.tigrfamUUID) {
      $.loadHmmscanAnnotation(global.annotation.tigrfamUUID, "tigrfam");
    }
    /* gene3d annotation */    if (global.annotation.gene3dUUID) {
      $.loadHmmscanAnnotation(global.annotation.gene3dUUID, "gene3d");
    }
    /* pirsf annotation */    if (global.annotation.pirsfUUID) {
      $.loadHmmscanAnnotation(global.annotation.pirsfUUID, "pirsf");
    }
    // Don't compute coverage and identity plots by default
    // $.when(ncoils, phobius, disorder).done(function() {
    //   if (typeof url_restrictions === 'undefined') {
    //     if (global.search_algo && global.search_algo === 'phmmer') {
    //       // compute coverage and identity only if the checkbox has been selected
    //       if (global.compute_coverage && global.compute_coverage === 'compute') {
    //         $.loadCoverageAndIdentityPlot(uuid);
    //       }
    //     }
    //   }
    //   $('.domwrapper .tooltip').tooltip();
    // });
    });
  // Compute coverage and identity plots on btn click
    $("#load_coverage_identity_heatmap").click(function() {
    console.log("loading coverage and identity heatmap");
    $.loadCoverageAndIdentityPlot(uuid);
    // hide the button after the ajax call has been performed
        $("#coverage_heatmap_loading_controls").css("display", "none");
    // show the div with loading text
        $("#coverage_heatmap_loading_text").css("display", "block");
  });
  $.loadPhmmer = function(uuid, status, page, withAli) {
    $(".hmmscanresult").find(".domwrapper > div").append($("<img/>").attr("src", site_url + "/static/images/loading.gif").attr("alt", "Annotating seq"));
    if (global.queryLength > 2e3) {
      $(".phmmerresult td").append("it might take a while");
    }
    $(".phmmerresult td").append($("<img/>").attr("src", site_url + "/static/images/loading.gif").attr("alt", "Searching seq"));
    // Make sure the search number is added to the UUID, so that the ajax
    // response is correct. Otherwise you get a nasty recursion.
        var current_url = window.location.pathname.replace(/^\/results\/[^\/]*/, "$&.1");
    $.ajax({
      url: current_url,
      data: {
        addpfam: 1,
        page: page,
        ali: withAli
      },
      statusCode: {
        /* If job has not run, tell the server to run it and get the results */
        202: function() {
          $.post(site_url + "/search/phmmer/" + uuid + ".1", {
            noredirect: 1
          }, function(response) {
            $.get(response.location, {
              addpfam: 1,
              page: page,
              ali: withAli
            }, function(data) {
              insertPhmmerIntoPage(data);
            });
          }, "json").fail(function() {
            console.error("ajax request failed");
            $(".phmmerresult").replaceWith("<h3>Search Failed</h3><p>We're sorry, it looks like " + "something went wrong with our search system. It may be a " + "transient error, so please feel free to try the search again. " + "Alternatively, please contact us.</p>");
          });
        },
        /* if job has already been run then just fetch results. */
        200: function(data) {
          insertPhmmerIntoPage(data);
        }
      }
    }).fail(function(jqXHR) {
      console.error("ajax request failed");
      console.error(jqXHR.responseText);
      $(".phmmerresult").replaceWith(jqXHR.responseText);
    });
  };
  var attachFormSubmissionOnPaginationInputs = function() {
    [].slice.call(document.querySelectorAll('input[name="page"]')).map(function(e) {
      e.addEventListener("blur", function() {
        e.form.submit();
      });
    });
  };
  attachFormSubmissionOnPaginationInputs();
  function insertPhmmerIntoPage(data) {
    $(".phmmerresult").replaceWith(data);
    $("#list .seqlink").seqpopup();
    $("#barGraph").distGraph();
    $(".meta").meta_toggle();
    $(".custom h5 a, .custom .title a").tooltip();
    $("#list caption span.right").addCustomToggle();
    if (global.hitPositionData) {
      $(".hitpos").hitLocation(global.hitPositionData);
    }
    $(".res_nav").show();
    $("body").data("phmmer.loaded", 1);
    // Don't compute coverage and identity plots by default
    // if (
    //   typeof url_restrictions === 'undefined' &&
    //   global.search_algo && global.search_algo === 'phmmer'
    // ) {
    //   $.loadCoverageAndIdentityPlot(uuid);
    // }
    // For every 'page' input, on blur, load the page with the chosen value
        attachFormSubmissionOnPaginationInputs();
    global.processXRefs();
  }
  $.loadNcoilsAnnotation = function(uuid) {
    return $.getJSON(site_url + "annotation/coils/" + uuid + "?graphics=1").done(function(data) {
      $("#domGraph").after('<div id="coilsGraph"></div>');
      data.graphic.title = "coiled-coil";
      data.graphic.imageParams = {
        motifHeight: 10,
        regionHeight: 10
      };
      var pg = new global.PfamGraphic("#coilsGraph", data.graphic);
      if (pg._sequence.motifs.length) {
        pg.render();
        var new_width = $("#domGraph").parent().width();
        pg.resize(new_width);
      }
      $("#ann_coiled").children("span").addClass("icon ann_ok").text("");
    }).fail(function() {
      $("#ann_coiled").children("span").addClass("icon ann_fail").text("");
    });
  };
  $.loadPhobiusAnnotation = function(uuid) {
    return $.getJSON(site_url + "annotation/phobius/" + uuid + "?graphics=1").done(function(data) {
      $("#domGraph").after('<div id="phobiusGraph"></div>');
      data.graphic.title = "tm & signal peptide";
      data.graphic.imageParams = {
        motifHeight: 10,
        regionHeight: 10
      };
      var pg = new global.PfamGraphic("#phobiusGraph", data.graphic);
      if (pg._sequence.motifs.length) {
        pg.render();
        var new_width = $("#domGraph").parent().width();
        pg.resize(new_width);
      }
      $("#ann_signal").children("span").addClass("icon ann_ok").text("");
    }).error(function() {
      $("#ann_signal").children("span").addClass("icon ann_fail").text("");
    });
  };
  $.loadDisorderAnnotation = function(uuid) {
    return $.getJSON(site_url + "annotation/disorder/" + uuid + "?graphics=1").done(function(data) {
      $("#domGraph").after('<div id="disorderGraph"></div>');
      data.graphic.title = "disorder";
      data.graphic.imageParams = {
        motifHeight: 10,
        regionHeight: 10
      };
      var pg = new global.PfamGraphic("#disorderGraph", data.graphic);
      if (pg._sequence.motifs.length) {
        pg.render();
        var new_width = $("#domGraph").parent().width();
        pg.resize(new_width);
      }
      $("#ann_disorder").children("span").addClass("icon ann_ok").text("");
    }).error(function() {
      $("#ann_disorder").children("span").addClass("icon ann_fail").text("");
    });
  };
  $.loadCoverageAndIdentityPlot = function() {
    var requested = false;
    return function(uuid) {
      if (requested) return;
 // Already requested, no need to do anything
            if ($("body").data("phmmer.loaded") && $("body").data("hmmscan.loaded")) {
        requested = true;
        $.getJSON(site_url + "annotation/coverageandidentity/" + uuid).done(function(data) {
          // hide the "loading..." div
          $("#coverage_heatmap_loading_text").css("display", "none");
          // show the plot
                    $("body").data("coverage_loaded", 1);
          $(".domwrapper > div").append($("#coverageTemplate").html());
          var width = $("#domGraph svg").width();
          $("#coverageheat").coverageHeatMap(data, width);
          var hm = $("#similarityheat").similarityHeatMap(data, width);
          if (width < 400) width = 400;
          var plus = document.querySelector("#heatmaps > a");
          plus.addEventListener("click", function() {
            $("#coverageGraph").show();
            if (!$("#coverageGraph svg").length) {
              var width = $("#domGraph svg").width();
              if (width < 400) {
                width = 400;
              }
              // have to show() first or things like getBBox() don't work
              // in subsequent methods as the graphic hasn't been
              // rendered on the page so the browser has no dimensions
              // to work with.
                            $("#coverageGraph").css({
                width: width
              });
              $("#coverageGraph").coveragePlot(data, width);
            }
            $("#heatmaps").hide();
          });
          plus.style.right = 
          // Center - half visual size of sequence - half+ size of text
          "calc(50% - " + hm.seq_length / 2 + "px - 55px)";
          plus.style.display = "block";
        });
      }
      // hide the "loading..." div
            $("#coverage_heatmap_loading_text").css("display", "block");
    };
  }();
  $.loadHmmscanAnnotation = function(uuid, type) {
    var titles = {
      tigrfam: "TIGRFAM",
      treefam: "TreeFam",
      superfamily: "Superfamily",
      gene3d: "Gene3D",
      pirsf: "PIRSF"
    };
    $.getJSON(site_url + "annotation/" + type + "/" + uuid, function(data) {
      $("#domGraph").after('<div id="' + type + 'Graph"></div>');
      data.graphic.title = titles[type];
      data.uuid = uuid;
      data.hits.forEach(function(hit) {
        hit.domains.forEach(function(domain) {
          if (domain.is_reported == "0") {
            domain.is_reported = "";
          }
          if (domain.significant == "0") {
            domain.significant = "";
            data.insignificant_count = 1;
          }
          if (domain.is_included == "0") {
            domain.is_included = "";
          }
        });
      });
      var source = $("#" + type + "-results-table").html();
      var template = Handlebars.compile(source);
      var html = template(data);
      $("." + type).replaceWith(html);
      $("#" + type + "Results").simpleTable();
      $("#" + type + "Results").sortable();
      if (data.graphic && data.graphic.regions && data.graphic.regions.length) {
        var pg = new global.PfamGraphic("#" + type + "Graph", data.graphic);
        pg.render();
        var new_width = $("#domGraph").parent().width();
        pg.resize(new_width);
        $("#" + type + "Results tbody tr:not('.alignment')").on("mouseover", function() {
          var uniq = $(this).attr("data-uniq");
          pg.highlight({
            uniq: uniq
          });
        }).on("mouseout", function() {
          var uniq = $(this).attr("data-uniq");
          pg.highlight({
            uniq: uniq,
            status: "off"
          });
        });
      }
    });
  };
  /****************** batch status checking ***********************/  $.fn.batchUpdate = function(data, uuid, algo) {
    var table = $(this);
    // update summary counts
        $(".summary_status .attention").text(data.summary.sum.searchnum);
    var statMessage = "Your job is queued behind " + data.queue.position + " other searches. (approximate wait time: " + data.queue.time + ")";
    if (data.queue.position === "0") {
      statMessage = "Your job is running.";
    }
    switch (data.summary.sum.status) {
     case "DONE":
      statMessage = "Your job has finished.";
      break;

     case "RUN":
      statMessage = "Your job is running.";
      break;

     case "ERROR":
      statMessage = "Your job failed to complete.";
      break;
    }
    $(".summary_status p:eq(1)").text(statMessage);
    if (data.summary.sum.status !== "DONE") {
      $(".summary_status p:eq(1)").append('<img src="/Tools/hmmer/static/images/spinner.gif"/>');
    } else {
      $(".summary_status p:eq(2)").remove();
    }
    if (data.summary.sum.searchnum) {
      // for each search result update the jobs that are finished.
      if (algo === "jackhmmer") {
        data.summary.results.forEach(function(result, i) {
          var row = table.find("tbody tr").eq(i);
          if (result.status === "DONE" || result.status === "RUN") {
            var link = $("<a>" + uuid + "." + (i + 1) + "</a>").attr("href", site_url + "/results/" + uuid + "." + (i + 1) + "/score");
            row.removeClass("pending").find("td:eq(5)").text(result.hitsnum).end().find("td:eq(1)").html(link).end();
            if (result.lost !== "-") {
              row.find("td:eq(3)").text("-" + result.lost).addClass("lost");
            }
            if (result.added !== "-") {
              row.find("td:eq(2)").text("+" + result.added).addClass("new");
            }
            if (result.lost_below !== "-") {
              row.find("td:eq(4)").text(result.lost_below).addClass("dropped");
            }
          } else if (result.status === "ERROR") {
            row.removeClass("pending").addClass("fail").find("td:eq(5)").text("-").end().find("td:eq(4)").text("-").end().find("td:eq(3)").text("-").end().find("td:eq(2)").text("-").end().find("td:eq(1)").text(result.errstr);
          }
        });
        if (data.summary.sum.converged) {
          table.find("tbody tr.pending").remove();
          table.find("caption").text("Jackhmmer Summary (Converged)");
        }
      } else {
        data.summary.results.forEach(function(result, i) {
          var row = table.find("tbody tr").eq(i);
          if (row.find("td:eq(3)").text() !== result.status) {
            if (result.status === "DONE" || result.status === "RUN") {
              var link = $("<a>show</a>").attr("href", site_url + "results/" + uuid + "." + (i + 1) + "/score");
              if (row.find("td").size() === 8) {
                row.removeClass("pending").find("td:eq(3)").text(result.status).end().find("td:eq(2)").text(result.hitsnum).end().find("td:eq(7)").html(link).end().find("td:eq(4)").text(result.tophit.acc).end().find("td:eq(5)").text(result.tophit.desc).end().find("td:eq(6)").text(result.tophit.evalue);
              } else {
                row.removeClass("pending").find("td:eq(3)").text(result.status).end().find("td:eq(2)").text(result.hitsnum).end().find("td:eq(6)").html(link).end().find("td:eq(4)").text(result.tophit.acc).end().find("td:eq(5)").text(result.tophit.desc).end();
              }
            } else if (result.status === "ERROR") {
              row.removeClass("pending").addClass("fail").find("td:eq(3)").text(result.status).end().find("td:eq(2)").text(result.errstr);
            }
          }
        });
      }
    }
    return;
  };
  /****************** distribution graphic ******************/  $.fn.distGraph = function() {
    if (!global.hitGraphData) return;
    if (!$("#barGraph").length) return;
    $(this).siblings().removeClass("hidden");
    // the graphic is already there if we find #barGraph
        if ($(this).children("#barGraph").children("svg").length) return;
    var height = 50;
    var width = 410;
    var paper = Raphael("barGraph", width, height);
    var data = global.hitGraphData[0].slice().reverse();
    var labels = global.hitGraphData[1].slice().reverse();
    var oMax = 0;
    var fills = [ "#900", // Bacteria
    "#f3c800", // Eukaryota
    "#009dcc", // Archaea
    "#630000", // Viruses
    "#999", // Unclassified Sequences
    "#333" ];
    var species = [ "Bacteria", "Eukaryota", "Archaea", "Viruses", "Unclassified Sequences", "Other Sequences" ];
    var classes = [ "bact", "euk", "arc", "vir", "unc", "oth" ];
    var animation = {
      delay: 50,
      duration: 250
    };
    var nBins = data.length;
    var remaining = 0;
    for (var j = 0; j < nBins; j++) {
      var colTotal = 0;
      for (var k = 0; k < data[j].length; k++) {
        remaining += parseInt(data[j][k], 10);
        colTotal += parseInt(data[j][k], 10);
      }
      if (colTotal > oMax) oMax = colTotal;
    }
    var supportsWebAnimation = !!document.body.animate;
    // draw an arrow to indicate low to high direction
        var arrow = paper.path("M0 25 L345 22 L345 18 L360 25 L345 33 L345 29 L0 25").attr({
      stroke: "#000",
      fill: "#999",
      opacity: "0.2"
    });
    if (supportsWebAnimation) {
      arrow.node.animate([ {
        transform: "translateX(-100%)"
      }, {
        transform: "translateX(0)"
      } ], {
        duration: animation.delay * nBins + animation.duration,
        fill: "forwards"
      });
    }
    // draw some text to indicate high vs low.
        paper.text(382, height / 2 + 1, "more\nsignificant").attr({
      fill: "#444"
    });
    for (var i = 0; i < nBins; i++) {
      // opacity, less significant -> more significant: 25% -> 100%
      var opacity = .25 + .75 * (i + 1) / nBins;
      // draw a grey line marker to indicate position of the bin
            var path = "M" + i * 12 + " " + (height - 1) + "L" + (i * 12 + 10) + " " + (height - 1);
      var hits = data[i].reduce(function(a, b) {
        return a + b;
      }, 0);
      // draw a rectangle for each data point if it is greater than 0
            if (hits) {
        paper.path(path).attr({
          stroke: "#666"
        });
        var label = labels[i];
        // work out remaining rows so we know where in the table to link to
                remaining -= hits;
        var row = remaining;
        var previous = 0;
        for (var t = 0; t < data[i].length; t++) {
          if (data[i][t] > 0) {
            //draw the scaled rectangles for each kingdom
            var pos = 47 * data[i][t] / oMax;
            var rect = paper.rect(i * 12, 47 - (pos + previous), 10, pos).attr({
              stroke: fills[t],
              fill: fills[t],
              opacity: opacity,
              "stroke-opacity": .8
            });
            if (supportsWebAnimation) {
              rect.node.animate([ {
                transform: "translateY(" + height + "px)"
              }, {
                transform: "translateY(0)"
              } ], {
                duration: animation.duration,
                delay: i * animation.delay,
                fill: "both",
                easing: "cubic-bezier(.38, .63, .15, 1.33)"
              });
            }
            previous += pos;
          }
        }
        // create a mouse over target that is bigger than the scaled column
                var target = paper.rect(i * 12, 0, 10, 47).attr({
          "stroke-opacity": 0,
          fill: "#FFE87C",
          stroke: "#FFE87C"
        }).click(function() {
          if (global.dist_data.rows === "All") {
            $("#list > tbody > tr").not(".ali").eq(this._row - 1).css("backgroundColor", "#ffe87c").animate({
              backgroundColor: "#fff"
            }, 3e3, function() {
              $(this).css("backgroundColor", "");
            })[0].scrollIntoView(false);
          } else {
            var targetPage = Math.ceil(this._row / parseInt(global.dist_data.rows, 10));
            if (targetPage === 0) {
              targetPage = 1;
            }
            if (targetPage == global.dist_data.page) {
              var targetRow = this._row - (global.dist_data.page - 1) * parseInt(global.dist_data.rows, 10);
              $("#list > tbody > tr").not(".ali").eq(targetRow - 1).css("backgroundColor", "#ffe87c").animate({
                backgroundColor: "#fff"
              }, 3e3, function() {
                $(this).css("backgroundColor", "");
              })[0].scrollIntoView(false);
            } else {
              var targetRow = this._row - (targetPage - 1) * parseInt(global.dist_data.rows);
              var url = site_url + "/results/" + global.dist_data.uuid + "/score?page=" + targetPage + ";row=r" + targetRow;
              if (global.dist_data.addpfam) {
                url += ";pfam=1";
              }
              window.location = url;
            }
          }
        });
        target.node.classList.add("target");
        // create the tool tip for each bin.
        //
                var title = "<p>E-value: " + label + "</p>";
        var text = '<ul class="breakdown">';
        for (var t = 0; t < data[i].length; t++) {
          if (data[i][t] > 0) {
            text += '<li class="' + classes[t] + '"><span>' + species[t] + ": " + data[i][t] + "</span></li>";
          }
        }
        text += "</ul>";
        $(target.node).qtip({
          position: {
            viewport: $(window),
            my: "bottom center",
            at: "top center"
          },
          content: {
            title: title,
            text: text
          },
          style: {
            classes: "ui-tooltip-hmmerdist ui-tooltip-rounded"
          }
        });
        target._row = row + 1;
      } else {
        paper.path(path).attr({
          stroke: "#ccc"
        });
      }
    }
    $("#disthelp").help();
  };
  /************************** misc functions ******************/  function hasLoadedTheTextarea() {
    return customElements && customElements.get("textarea-sequence") && document.getElementById("textarea_seq");
  }
  function loadExample(e, ex) {
    if (hasLoadedTheTextarea()) {
      document.getElementById("textarea_seq").quill.setText(ex);
    } else {
      $("textarea").val(ex).text(ex).change();
    }
    e.preventDefault();
  }
})(jQuery, __HmmerGlobal);

//Fix for toggle(function, function, ...) being removed in jquery 1.9
//Fix for toggle(function, function, ...) being removed in jquery 1.9
(function($) {
  $.fn.toggler = function(fn) {
    var args = arguments;
    var guid = fn.guid || $.guid++;
    var i = 0;
    var toggler = function(event) {
      var lastToggle = ($._data(this, "lastToggle" + fn.guid) || 0) % i;
      $._data(this, "lastToggle" + fn.guid, lastToggle + 1);
      event.preventDefault();
      return args[lastToggle].apply(this, arguments) || false;
    };
    toggler.guid = guid;
    while (i < args.length) {
      args[i++].guid = guid;
    }
    return this.click(toggler);
  };
})(jQuery);

(function($) {
  $(".youTubeVideo").click(function() {
    try {
      ga("send", "event", "video", "display", "home page");
    } catch (e) {}
    $(".youtube").show();
    $(".popup.youtube, .overlaybg").show();
  });
  $(".close, .overlaybg").click(function() {
    document.querySelector("video").pause();
    $(".popup.youtube, .overlaybg").hide();
  });
})(jQuery);
// Prefetch or prerender some pages
/*(function() {
  var timeout;
  // Create only one link tag that will be used and reused later
  var link = document.createElement('link');
  var handleMouseLeave = function handleMouseLeave(e) {
    // When the mouses leaves, cancels the timeout if it is still waiting
    clearTimeout(timeout);
    // And removes itself from the target
    e.target.removeEventListener('mouseleave', handleMouseLeave);
  };

  link.rel = 'prefetch prerender';
  document.head.appendChild(link);

  document.addEventListener('mouseover', function(e) {
    // If it doesn't have the custom attribute data-prefetchprerender
    if (
      !e.target.dataset ||
      e.target.dataset.prefetchprerender === undefined
    ) return;// Pass
    // If the href of the target is different that the one in the link
    // To avoid re-setting the href of the link
    if (link.href !== e.target.href) {
      // Cancel any existing timeout
      clearTimeout(timeout);
      // Set new timeout for 200ms
      timeout = setTimeout(function() {
        // After the timeout, set the href of the link
        link.href = e.target.href;
      }, 200);
      // Add an event listener for when the mouse leaves the target
      e.target.addEventListener('mouseleave', handleMouseLeave);
    }
  });
})();*/
//# sourceMappingURL=main.min.js.map